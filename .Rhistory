ss_plots <- ggarrange(p2, p4, p1, p7, grob_leg, p6, p5, p3, p8, ncol = 5, nrow = 2)
# Print to PDF
pdf("Results/Final_Pipeline/single_stressor_plots.pdf", width = 20, height = 8, onefile = FALSE) # setting onefile to false prevents a blank leading page
ss_plots
dev.off()
setwd(here())
# Modifies tidy_data to produce isolate_single_stress, which is limited to growth data by isolate by stressor. Prints to pdf.
# Requires Well_Data_Loader.R, and Growth_Curve_Loop.R
library(dplyr)
library(tibble)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
library(cowplot)
setwd(here("scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# A colour vector for consistent colouring
stressor_colours <- c("Copper" = "red", "Nickel" = "darkred", "Chloramphenicol" = "darkmagenta", "Ampicillin" = "magenta", "Atrazine" = "green", "Metaldehyde" = "darkgreen", "Tebuconazole" = "blue", "Azoxystrobin" = "darkblue", "None" = "black")
# We can graph the effects of different single stressors on bacteria. For instance:
isolate_single_stress <- tidy_data %>%
filter((Copper + Nickel + Chloramphenicol + Ampicillin + Atrazine + Metaldehyde + Tebuconazole + Azoxystrobin) <= 1) %>%
select(-location) %>%
mutate(Stressor = "None")
# A for loop to turn presence/absence data into a single variable (only works for single stressors). I am not proud of how long this took to implement.
for (m in 1:nrow(isolate_single_stress))
{
for (n in 1:8)
{
if (isolate_single_stress[m,n+3] == 1)
{
isolate_single_stress$Stressor[m] = colnames(isolate_single_stress[,n+3])
}
}
}
# Get rid of the presence/absence stressor data
isolate_single_stress <- isolate_single_stress %>%
select(-Copper, -Nickel, -Chloramphenicol, -Ampicillin, -Metaldehyde, -Atrazine, -Tebuconazole, -Azoxystrobin, -Run)
# Calculates one mean and SD for every combination of isolate, stressor and time point
isolate_single_stress <- isolate_single_stress %>%
group_by(Isolate, Stressor, time) %>%
summarise(Mean_OD = mean(OD), SD_OD = sd(OD)) %>%
distinct() %>%
filter(time < 26)
# for loop across the 8 isolates to produce a 4x2 lattice of graphs
# TODO: still needs logistic curves fitted
for (o in 1:8)
{
temp_isolate <- isolates_vector[o]
temp_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
geom_point(aes(colour = Stressor), size = 1, shape = 16, alpha = 1) +
scale_colour_manual(values = stressor_colours) +
theme(legend.position="none") +
ylim(0.04,0.35) +
scale_shape_identity() +
geom_smooth(aes(colour = Stressor), method="loess", se = FALSE) +
ggtitle(isolates_species_vector[o]) +
theme(axis.title.x=element_blank(),
axis.title.y=element_blank()) +
# Add a control line
geom_hline(yintercept = 0.05, colour = "grey")
#scale_colour_manual(values = stressor_colours)
temp_plot_name <- paste("p", o ,sep = "")
assign(temp_plot_name, temp_plot)
}
# Plot a dummy graph so we can get a legend.
dummy_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
geom_point(aes(colour = Stressor), size = 1, shape = 16, alpha = 1) +
scale_colour_manual(values = stressor_colours, limits = names(stressor_colours)) +
scale_shape_identity() +
geom_smooth(aes(colour = Stressor), method="loess", se = FALSE) +
geom_hline(yintercept = 0.05, colour = "grey")
grob_leg <- get_legend(dummy_plot)
# Arange the plots 4x2 with a shared legend
ss_plots <- ggarrange(p2, p4, p1, p7, grob_leg, p6, p5, p3, p8, ncol = 5, nrow = 2)
# Print to PDF
png("Results/Final_Pipeline/single_stressor_plots.png", width = 20, height = 8, onefile = FALSE) # setting onefile to false prevents a blank leading page
ss_plots
dev.off()
setwd(here())
# Modifies tidy_data to produce isolate_single_stress, which is limited to growth data by isolate by stressor. Prints to pdf.
# Requires Well_Data_Loader.R, and Growth_Curve_Loop.R
library(dplyr)
library(tibble)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
library(cowplot)
setwd(here("scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# A colour vector for consistent colouring
stressor_colours <- c("Copper" = "red", "Nickel" = "darkred", "Chloramphenicol" = "darkmagenta", "Ampicillin" = "magenta", "Atrazine" = "green", "Metaldehyde" = "darkgreen", "Tebuconazole" = "blue", "Azoxystrobin" = "darkblue", "None" = "black")
# We can graph the effects of different single stressors on bacteria. For instance:
isolate_single_stress <- tidy_data %>%
filter((Copper + Nickel + Chloramphenicol + Ampicillin + Atrazine + Metaldehyde + Tebuconazole + Azoxystrobin) <= 1) %>%
select(-location) %>%
mutate(Stressor = "None")
# A for loop to turn presence/absence data into a single variable (only works for single stressors). I am not proud of how long this took to implement.
for (m in 1:nrow(isolate_single_stress))
{
for (n in 1:8)
{
if (isolate_single_stress[m,n+3] == 1)
{
isolate_single_stress$Stressor[m] = colnames(isolate_single_stress[,n+3])
}
}
}
# Get rid of the presence/absence stressor data
isolate_single_stress <- isolate_single_stress %>%
select(-Copper, -Nickel, -Chloramphenicol, -Ampicillin, -Metaldehyde, -Atrazine, -Tebuconazole, -Azoxystrobin, -Run)
# Calculates one mean and SD for every combination of isolate, stressor and time point
isolate_single_stress <- isolate_single_stress %>%
group_by(Isolate, Stressor, time) %>%
summarise(Mean_OD = mean(OD), SD_OD = sd(OD)) %>%
distinct() %>%
filter(time < 26)
# for loop across the 8 isolates to produce a 4x2 lattice of graphs
# TODO: still needs logistic curves fitted
for (o in 1:8)
{
temp_isolate <- isolates_vector[o]
temp_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
geom_point(aes(colour = Stressor), size = 1, shape = 16, alpha = 1) +
scale_colour_manual(values = stressor_colours) +
theme(legend.position="none") +
ylim(0.04,0.35) +
scale_shape_identity() +
geom_smooth(aes(colour = Stressor), method="loess", se = FALSE) +
ggtitle(isolates_species_vector[o]) +
theme(axis.title.x=element_blank(),
axis.title.y=element_blank()) +
# Add a control line
geom_hline(yintercept = 0.05, colour = "grey")
#scale_colour_manual(values = stressor_colours)
temp_plot_name <- paste("p", o ,sep = "")
assign(temp_plot_name, temp_plot)
}
# Plot a dummy graph so we can get a legend.
dummy_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
geom_point(aes(colour = Stressor), size = 1, shape = 16, alpha = 1) +
scale_colour_manual(values = stressor_colours, limits = names(stressor_colours)) +
scale_shape_identity() +
geom_smooth(aes(colour = Stressor), method="loess", se = FALSE) +
geom_hline(yintercept = 0.05, colour = "grey")
grob_leg <- get_legend(dummy_plot)
# Arange the plots 4x2 with a shared legend
ss_plots <- ggarrange(p2, p4, p1, p7, grob_leg, p6, p5, p3, p8, ncol = 5, nrow = 2)
# Print to PDF
png("Results/Final_Pipeline/single_stressor_plots.png", width = 20, height = 8) # setting onefile to false prevents a blank leading page
ss_plots
dev.off()
setwd(here())
# Modifies tidy_data to produce isolate_single_stress, which is limited to growth data by isolate by stressor. Prints to pdf.
# Requires Well_Data_Loader.R, and Growth_Curve_Loop.R
library(dplyr)
library(tibble)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
library(cowplot)
setwd(here("scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# A colour vector for consistent colouring
stressor_colours <- c("Copper" = "red", "Nickel" = "darkred", "Chloramphenicol" = "darkmagenta", "Ampicillin" = "magenta", "Atrazine" = "green", "Metaldehyde" = "darkgreen", "Tebuconazole" = "blue", "Azoxystrobin" = "darkblue", "None" = "black")
# We can graph the effects of different single stressors on bacteria. For instance:
isolate_single_stress <- tidy_data %>%
filter((Copper + Nickel + Chloramphenicol + Ampicillin + Atrazine + Metaldehyde + Tebuconazole + Azoxystrobin) <= 1) %>%
select(-location) %>%
mutate(Stressor = "None")
# A for loop to turn presence/absence data into a single variable (only works for single stressors). I am not proud of how long this took to implement.
for (m in 1:nrow(isolate_single_stress))
{
for (n in 1:8)
{
if (isolate_single_stress[m,n+3] == 1)
{
isolate_single_stress$Stressor[m] = colnames(isolate_single_stress[,n+3])
}
}
}
# Get rid of the presence/absence stressor data
isolate_single_stress <- isolate_single_stress %>%
select(-Copper, -Nickel, -Chloramphenicol, -Ampicillin, -Metaldehyde, -Atrazine, -Tebuconazole, -Azoxystrobin, -Run)
# Calculates one mean and SD for every combination of isolate, stressor and time point
isolate_single_stress <- isolate_single_stress %>%
group_by(Isolate, Stressor, time) %>%
summarise(Mean_OD = mean(OD), SD_OD = sd(OD)) %>%
distinct() %>%
filter(time < 26)
# for loop across the 8 isolates to produce a 4x2 lattice of graphs
# TODO: still needs logistic curves fitted
for (o in 1:8)
{
temp_isolate <- isolates_vector[o]
temp_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
geom_point(aes(colour = Stressor), size = 1, shape = 16, alpha = 1) +
scale_colour_manual(values = stressor_colours) +
theme(legend.position="none") +
ylim(0.04,0.35) +
scale_shape_identity() +
geom_smooth(aes(colour = Stressor), method="loess", se = FALSE) +
ggtitle(isolates_species_vector[o]) +
theme(axis.title.x=element_blank(),
axis.title.y=element_blank()) +
# Add a control line
geom_hline(yintercept = 0.05, colour = "grey")
#scale_colour_manual(values = stressor_colours)
temp_plot_name <- paste("p", o ,sep = "")
assign(temp_plot_name, temp_plot)
}
# Plot a dummy graph so we can get a legend.
dummy_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
geom_point(aes(colour = Stressor), size = 1, shape = 16, alpha = 1) +
scale_colour_manual(values = stressor_colours, limits = names(stressor_colours)) +
scale_shape_identity() +
geom_smooth(aes(colour = Stressor), method="loess", se = FALSE) +
geom_hline(yintercept = 0.05, colour = "grey")
grob_leg <- get_legend(dummy_plot)
# Arange the plots 4x2 with a shared legend
ss_plots <- ggarrange(p2, p4, p1, p7, grob_leg, p6, p5, p3, p8, ncol = 5, nrow = 2)
# Print to PDF
png("Results/Final_Pipeline/single_stressor_plots.png", width = 2000, height = 800) # setting onefile to false prevents a blank leading page
ss_plots
dev.off()
setwd(here())
# Produces a basic plot of mixture complexity against a variety of metrics of growth from Growth_Curve_Loop.R. Prints to pdf.
# TODO: What's the statistical validity of any of this? How can I best represent it?
# TODO: Figure out the big deal with carrying capacity.
library(dplyr)
library(tidyverse)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
setwd(here("Scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# Let's graph a bunch of growth parameters against stressor richness
# First things first: transmute stressor presence/absence to a single richness column
richness_growth_data <- tidier_growth_data %>%
select(Richness, Isolate, Mean, SD) %>%
filter(Isolate != "Control")
# and for the sake of completeness
richness_functional_growth_data <- aggregate_functional_groups(tidier_growth_data) %>%
select(Richness, Species, Mean, SD) %>%
filter(Species != "Control")
# And graph growth against richness, by species of bacteria
growthXrichness_mean <- ggplot(richness_growth_data, aes(Richness, Mean)) +
geom_jitter(aes(colour = Isolate, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e")
growthXfunc_richness_mean <- ggplot(richness_functional_growth_data, aes(Richness, Mean)) +
geom_jitter(aes(colour = Species, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Species, colour = Species), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e by Species")
lm_anova <- anova(lm_MxR, lm_MxR_F)
# A non-visual measure of fit goodness would also be a good idea
lm_MxR <- lm(Mean ~ Richness + Isolate, richness_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR)
cor.test(richness_growth_data$Mean, richness_growth_data$Richness, use = "pairwise")
summary(lm_MxR)
# By species
lm_MxR_F <- lm(Mean ~ Species + Richness, richness_functional_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR_F)
summary(lm_MxR_F)
# Basically species and isolate currently explain variation well, and richness doesn't. Which doesn't seem right...
lm_anova <- anova(lm_MxR, lm_MxR_F)
lm_anova
# Produces a basic plot of mixture complexity against a variety of metrics of growth from Growth_Curve_Loop.R. Prints to pdf.
# TODO: What's the statistical validity of any of this? How can I best represent it?
# TODO: Figure out the big deal with carrying capacity.
library(dplyr)
library(tidyverse)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
setwd(here("Scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# Let's graph a bunch of growth parameters against stressor richness
# First things first: transmute stressor presence/absence to a single richness column
richness_growth_data <- tidier_growth_data %>%
select(Richness, Isolate, Mean, SD) %>%
filter(Isolate != "Control")
# and for the sake of completeness
richness_functional_growth_data <- aggregate_functional_groups(tidier_growth_data) %>%
select(Richness, Species, Mean, SD) %>%
filter(Species != "Control")
# And graph growth against richness, by species of bacteria
growthXrichness_mean <- ggplot(richness_growth_data, aes(Richness, Mean)) +
geom_jitter(aes(colour = Isolate, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e")
growthXfunc_richness_mean <- ggplot(richness_functional_growth_data, aes(Richness, Mean)) +
geom_jitter(aes(colour = Species, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Species, colour = Species), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e by Species")
# # Same for auc_l
# growthXrichness_auc_l <- ggplot(richness_growth_data, aes(Richness, Growth_auc_l)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("auc_l")
#
# # Same for k (max growth?)
# growthXrichness_k <- ggplot(richness_growth_data, aes(Richness, Growth_k)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ylim(0, 1) + # TODO: What's going on here? More of the Ks ~= 0
#   ggtitle("carrying capacity")
#
# # might as well also do
# growthXrichness_r <- ggplot(richness_growth_data, aes(Richness, Growth_r)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("growth rate")
# We can do some linear modelling later and obtain some idea of the statistical soundness behind our measurements...
png("Results/Final_Pipeline/growthXrichness.png", width = 1600, height = 800)
# ggarrange(growthXrichness_auc_e, growthXrichness_auc_l, growthXrichness_k, growthXrichness_r, common.legend = TRUE, legend = "right", ncol = 2, nrow = 2)
growthXfunc_richness_mean
dev.off()
# A non-visual measure of fit goodness would also be a good idea
lm_MxR <- lm(Mean ~ Richness + Isolate, richness_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR)
cor.test(richness_growth_data$Mean, richness_growth_data$Richness, use = "pairwise")
summary(lm_MxR)
# By species
lm_MxR_F <- lm(Mean ~ Species + Richness, richness_functional_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR_F)
summary(lm_MxR_F)
# Basically species and isolate currently explain variation well, and richness doesn't. Which doesn't seem right...
lm_anova <- anova(lm_MxR, lm_MxR_F)
setwd(here())
temp_stressors <- vector(length = 8)
?vector
temp_stressors <- vector(mode = "numerical", length = 8)
temp_stressors <- vector(mode = "numeric", length = 8)
temp_stressors[q] <- single_stressor_growth_data$mean_effect[q]
temp_stressors[q]
max(c(0,1,2,3))
max(c(0,1,2,3),5,6)
# Modifies tidier_growth_data to create Piggott et al. interaction definitions for every combination of stressors by isolate
# Also converts presence/absence data into columns for S1, S2, S3, etc
# Requires a whole buncha stuff.
# TODO: Make.
library(dplyr)
library(tibble)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(data.table)
setwd(here("Scripts"))
source("Code/Final_Pipeline/t.test2.R")
source("Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R")
# Set your p-cutoff for additivism here
p_cutoff <- 0.05
# Calculate the effect of individual stressors relative to controls, by isolate
all_interactions_tibble <- tibble()
for (s in 1:8)
{
# Create a tibble of all measurements for our chosen isolate
isolate_tidier_growth_data <- tidier_growth_data %>%
select(Copper, Nickel, Chloramphenicol, Ampicillin, Metaldehyde, Atrazine, Tebuconazole, Azoxystrobin, Isolate, Mean, SD, Richness, n) %>%
filter(Isolate == isolates_vector[s])
# Calculate a baseline from controls
control_baseline <- isolate_tidier_growth_data %>%
filter(Richness == 0) %>%
select(Isolate, Mean, SD, n)
# A tibble of single stressors
single_stressor_growth_data <- isolate_tidier_growth_data %>%
filter(Richness == 1) %>%
mutate(mean_effect = Mean - control_baseline$Mean) %>%
mutate(sd_effect = sqrt((SD ^ 2) + (control_baseline$SD ^ 2))) %>% # New SD is the square root of the summed squared SDs
mutate(n_effect = n) %>%
mutate(Stressor = "")
# This breaks a lot currently as I don't always have a measurement for every single stressor/isolate combination
# Loop across the single stressor info to make sure they all get the right stressor assigned to the right effect
for (p in 1:nrow(single_stressor_growth_data))
{
for (q in 1:8)
{
if (single_stressor_growth_data[p,q] == 1)
{
single_stressor_growth_data$Stressor[p] <- colnames(single_stressor_growth_data[q])
}
}
}
# get rid of presence/absence columns
single_stressor_growth_data <- single_stressor_growth_data %>%
select(-Copper, -Nickel, -Chloramphenicol, -Ampicillin, -Metaldehyde, -Atrazine, -Tebuconazole, -Azoxystrobin, -Mean, -SD, -Richness, -n)
# This ugly boy here reorders the single stressor data to stressors_vector so I don't accidentally predict using the wrong data!
single_stressor_growth_data$Stressor <- factor(single_stressor_growth_data$Stressor, levels = stressors_vector)
single_stressor_growth_data <- single_stressor_growth_data[order(single_stressor_growth_data$Stressor),]
# And all mixtures
mixture_tidier_growth_data <- isolate_tidier_growth_data %>%
filter(Richness > 1) %>%
mutate(obs_mean = Mean - control_baseline$Mean) %>%
mutate(obs_sd = sqrt((SD ** 2) + (control_baseline$SD ** 2))) %>%
mutate(obs_n = n) %>%
mutate(pred_mean = 0) %>%
mutate(pred_sd = 0) %>%
mutate(pred_n = 0) %>%
mutate(Interaction = "") %>%
select(-Mean, -SD, -n)
# For loop across all the mixtures
for (p in 1:nrow(mixture_tidier_growth_data))
{
mixture_counter <- 0
temp_stressors <- vector(mode = "numeric", length = 8)
for (q in 1:8)
{
if ((mixture_tidier_growth_data[p,q] == 1) && (mixture_counter < mixture_tidier_growth_data$Richness[p]))
{
# If a stressor is present, add the relevant means and sd from single_stressor_growth_data
# We're summming means here because we're calculating an additive effect
mixture_tidier_growth_data$pred_mean[p] <- mixture_tidier_growth_data$pred_mean[p] + single_stressor_growth_data$mean_effect[q]
mixture_tidier_growth_data$pred_sd[p] <- sqrt((mixture_tidier_growth_data$pred_sd[p] ^ 2) + (single_stressor_growth_data$sd_effect[q] ^ 2))
mixture_tidier_growth_data$pred_n[p] <- mixture_tidier_growth_data$pred_n[p] + single_stressor_growth_data$n_effect[q]
mixture_counter <- mixture_counter + 1
# And append the stressor effect to temp_stressors so we can calculate the regions of Piggott synergy and antagonism
temp_stressors[q] <- single_stressor_growth_data$mean_effect[q]
}
if (mixture_counter == mixture_tidier_growth_data$Richness[p])
{
# Once the additive mean and sd are calculated, we can compare the two to determine the interaction type. This is where it gets complicated.
# Divide the pred_n by richness and round it up
mixture_tidier_growth_data$pred_n[p] <- ceiling((mixture_tidier_growth_data$pred_n[p])/(mixture_tidier_growth_data$Richness[p]))
# Now we need to t-test the observed vs predicted effect. We'll be rejecting the null hypothesis for p < 0.05
additive_test <- t.test2(mixture_tidier_growth_data$pred_mean[p], mixture_tidier_growth_data$obs_mean[p],
mixture_tidier_growth_data$pred_sd[p], mixture_tidier_growth_data$obs_sd[p],
mixture_tidier_growth_data$pred_n[p], mixture_tidier_growth_data$obs_n[p])
# We also need to catch NaNs and NAs
# Set some upper and lower bounds of synergies for cleaner code
upper_bound <- max(mixture_tidier_growth_data$pred_mean[p], temp_stressors, 0)
lower_bound <- min(mixture_tidier_growth_data$pred_mean[p], temp_stressors, 0)
if (is.na(additive_test[4]) || is.nan(additive_test[4]))
{
mixture_tidier_growth_data$Interaction[p] <- "T-test error"
} else if (additive_test[4] >= p_cutoff)
{
mixture_tidier_growth_data$Interaction[p] <- "Additive"
} else if (mixture_tidier_growth_data$obs_mean[p] > upper_bound)
{
mixture_tidier_growth_data$Interaction[p] <- "+ Synergy"
} else if (mixture_tidier_growth_data$obs_mean[p] < lower_bound)
{
mixture_tidier_growth_data$Interaction[p] <- "- Synergy"
} else if (mixture_tidier_growth_data$obs_mean[p] < mixture_tidier_growth_data$pred_mean[p])
{
mixture_tidier_growth_data$Interaction[p] <- "- Antagonism"
} else if (mixture_tidier_growth_data$obs_mean[p] > mixture_tidier_growth_data$pred_mean[p])
{
mixture_tidier_growth_data$Interaction[p] <- "+ Antagonism"
} else
{
mixture_tidier_growth_data$Interaction[p] <- "Classification Error"
}
# This is crude, I think it works.
mixture_counter <- 0
}
}
}
all_interactions_tibble <- bind_rows(all_interactions_tibble, mixture_tidier_growth_data)
}
# Think of this as a diagnostic plot.
ggplot(data = filter(all_interactions_tibble), aes(x = obs_mean, y = pred_mean, colour = Interaction)) +
geom_point() +
geom_abline(slope = 1, intercept = 0)
# Diagnosis: a bad dataset.
all_interactions_tibble
View(all_interactions_tibble)
ggplot(data = filter(all_interactions_tibble), aes(x = obs_mean, y = pred_mean, colour = Interaction)) +
geom_point() +
geom_abline(slope = 1, intercept = 0)
ggplot(data = all_interactions_tibble, aes(x = Isolate, colour = Interaction)) +
geom_col()
ggplot(data = all_interactions_tibble, aes(x = Isolate, colour = Interaction)) +
geom_bar()
test <- ggplot(data = all_interactions_tibble, aes(x = Isolate, colour = Interaction)) +
geom_bar()
# Diagnosis: a bad dataset.
test
ggplot(data = all_interactions_tibble, aes(x = Isolate, colour = Interaction))
ggplot(data = all_interactions_tibble, aes(x = Isolate)) +
geom_bar()
