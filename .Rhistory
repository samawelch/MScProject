library(gridBase)
library(gridExtra)
library(ggpubr)
library(cowplot)
setwd(here("scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# A colour vector for consistent colouring
stressor_colours <- c("Copper" = "red", "Nickel" = "darkred", "Chloramphenicol" = "darkmagenta", "Ampicillin" = "magenta", "Atrazine" = "green", "Metaldehyde" = "darkgreen", "Tebuconazole" = "blue", "Azoxystrobin" = "darkblue", "None" = "black")
# We can graph the effects of different single stressors on bacteria. For instance:
isolate_single_stress <- tidy_data %>%
filter((Copper + Nickel + Chloramphenicol + Ampicillin + Atrazine + Metaldehyde + Tebuconazole + Azoxystrobin) <= 1) %>%
select(-location) %>%
mutate(Stressor = "Control")
# A for loop to turn presence/absence data into a single variable (only works for single stressors). I am not proud of how long this took to implement.
for (m in 1:nrow(isolate_single_stress))
{
for (n in 1:8)
{
if (isolate_single_stress[m,n+3] == 1)
{
isolate_single_stress$Stressor[m] = colnames(isolate_single_stress[,n+3])
}
}
}
# Get rid of the presence/absence stressor data
isolate_single_stress <- isolate_single_stress %>%
select(-Copper, -Nickel, -Chloramphenicol, -Ampicillin, -Metaldehyde, -Atrazine, -Tebuconazole, -Azoxystrobin, -Run)
# Calculates one mean and SD for every combination of isolate, stressor and time point
isolate_single_stress <- isolate_single_stress %>%
group_by(Isolate, Stressor, time) %>%
summarise(Mean_OD = mean(OD), SD_OD = sd(OD), n = n()) %>%
distinct()
# What happens if we gate it down to every 4th point?
isolate_single_stress <- isolate_single_stress %>%
filter((time %% 4 == 0))
# for loop across the 8 isolates to produce a 4x2 lattice of graphs
for (o in 1:8)
{
temp_isolate <- isolates_vector[o]
temp_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
theme(legend.position="none") +
ylim(0,0.5) +
geom_errorbar(aes(colour = Stressor, ymin = Mean_OD - SD_OD, ymax = Mean_OD + SD_OD), position = position_dodge(width = 5)) +
geom_smooth(aes(colour = Stressor), se = FALSE, method = "loess") +
ggtitle(isolates_species_vector[o]) +
theme(axis.title.x=element_blank(),
axis.title.y=element_blank()) +
scale_colour_discrete(labels = c("Copper", "Nickel", "Chloramphenicol", "Ampicillin", "Atrazine", "Metaldehyde", "Tebuconazole", "Azokystrobin", "Control"))
# Add a control line
geom_hline(yintercept = 0.05, colour = "grey")
#scale_colour_manual(values = stressor_colours)
temp_plot_name <- paste("p", o ,sep = "")
assign(temp_plot_name, temp_plot)
}
# Plot a dummy graph so we can get a legend.
dummy_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
geom_point(aes(colour = Stressor), size = 1, shape = 16, alpha = 1) +
scale_shape_identity() +
geom_smooth(aes(colour = Stressor), method="loess", se = FALSE) +
geom_hline(yintercept = 0.05, colour = "grey")
grob_leg <- get_legend(dummy_plot)
# Arange the plots with a shared legend
ss_plots <- ggarrange(p2, p4, p1, p7, p6, p5, p3, p8, grob_leg, ncol = 3, nrow = 3)
# Print to PDF
pdf("Results/Final_Pipeline/single_stressor_plots.pdf", width = 9, height = 9) # setting onefile to false prevents a blank leading page
ss_plots
dev.off()
dev.off()
setwd(here())
# Produces a basic plot of mixture complexity against a variety of metrics of growth from Growth_Curve_Loop.R. Prints to pdf.
# TODO: What's the statistical validity of any of this? How can I best represent it?
# TODO: Figure out the big deal with carrying capacity.
library(dplyr)
library(tidyverse)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
library(tikzDevice)
library(here)
setwd(here("Scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# Let's graph a bunch of growth parameters against stressor richness
# First things first: transmute stressor presence/absence to a single richness column
richness_growth_data <- tidier_growth_data %>%
select(Richness, Isolate, Mean, SD) %>%
filter(Isolate != "Control")
# and for the sake of completeness
richness_functional_growth_data <- aggregate_functional_groups(tidier_growth_data) %>%
select(Richness, Species, Mean, SD) %>%
filter(Species != "Control")
# And graph growth against richness, by species of bacteria
growthXrichness_mean <- ggplot(richness_growth_data, aes(Richness, Mean)) +
geom_jitter(aes(colour = Isolate, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e")
growthXfunc_richness_mean <- ggplot(richness_functional_growth_data, aes(as.factor(Richness), Mean)) +
geom_smooth(aes(group = Species, colour = Species), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean Growth by Species") +
xlab("Mixture Complexity") +
ylab("Mean Growth")
# # Same for auc_l
# growthXrichness_auc_l <- ggplot(richness_growth_data, aes(Richness, Growth_auc_l)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("auc_l")
#
# # Same for k (max growth?)
# growthXrichness_k <- ggplot(richness_growth_data, aes(Richness, Growth_k)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ylim(0, 1) + # TODO: What's going on here? More of the Ks ~= 0
#   ggtitle("carrying capacity")
#
# # might as well also do
# growthXrichness_r <- ggplot(richness_growth_data, aes(Richness, Growth_r)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("growth rate")
# We can do some linear modelling later and obtain some idea of the statistical soundness behind our measurements...
png("Results/Final_Pipeline/growthXrichness.png", width = 1600, height = 800)
# ggarrange(growthXrichness_auc_e, growthXrichness_auc_l, growthXrichness_k, growthXrichness_r, common.legend = TRUE, legend = "right", ncol = 2, nrow = 2)
growthXfunc_richness_mean
dev.off()
# A non-visual measure of fit goodness would also be a good idea
lm_MxR <- lm(Mean ~ Richness + Isolate, richness_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR)
cor.test(richness_growth_data$Mean, richness_growth_data$Richness, use = "pairwise")
summary(lm_MxR)
# By species
lm_MxR_F <- lm(Mean ~ Species + Richness, richness_functional_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR_F)
summary(lm_MxR_F)
# Basically species and isolate currently explain variation well, and richness doesn't. Which doesn't seem right...
lm_anova <- anova(lm_MxR, lm_MxR_F)
# Let's try tikz
tikz("Results/Final_Pipeline/growthXrichness.tex", width = 3.5, height = 3.5)
growthXfunc_richness_mean
dev.off()
library(tikzDevice)
tikz('Results/simpleEx.tex',width=3.5,height=3.5)
plot(1,main='Hello World!')
dev.off()
growthXfunc_richness_mean
# Produces a basic plot of mixture complexity against a variety of metrics of growth from Growth_Curve_Loop.R. Prints to pdf.
library(dplyr)
library(tidyverse)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
library(tikzDevice)
library(here)
setwd(here("Scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# Let's graph a bunch of growth parameters against stressor richness
# First things first: transmute stressor presence/absence to a single richness column
richness_growth_data <- tidier_growth_data %>%
select(Richness, Isolate, Mean, SD) %>%
filter(Isolate != "Control")
# and for the sake of completeness
richness_functional_growth_data <- aggregate_functional_groups(tidier_growth_data) %>%
select(Richness, Species, Mean, SD) %>%
filter(Species != "Control")
# And graph growth against richness, by species of bacteria
growthXrichness_mean <- ggplot(richness_growth_data, aes(Richness, Mean)) +
geom_jitter(aes(colour = Isolate, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e")
growthXfunc_richness_mean <- ggplot(richness_functional_growth_data, aes(as.factor(Richness), Mean)) +
geom_smooth(aes(group = Species, colour = Species), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean Growth by Species") +
xlab("Mixture Complexity") +
ylab("Mean Growth")
# # Same for auc_l
# growthXrichness_auc_l <- ggplot(richness_growth_data, aes(Richness, Growth_auc_l)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("auc_l")
#
# # Same for k (max growth?)
# growthXrichness_k <- ggplot(richness_growth_data, aes(Richness, Growth_k)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ylim(0, 1) + # TODO: What's going on here? More of the Ks ~= 0
#   ggtitle("carrying capacity")
#
# # might as well also do
# growthXrichness_r <- ggplot(richness_growth_data, aes(Richness, Growth_r)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("growth rate")
# We can do some linear modelling later and obtain some idea of the statistical soundness behind our measurements...
pdf("Results/Final_Pipeline/growthXrichness.png", width = 9, height = 6)
# ggarrange(growthXrichness_auc_e, growthXrichness_auc_l, growthXrichness_k, growthXrichness_r, common.legend = TRUE, legend = "right", ncol = 2, nrow = 2)
growthXrichness_mean
dev.off()
# A non-visual measure of fit goodness would also be a good idea
lm_MxR <- lm(Mean ~ Richness + Isolate, richness_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR)
cor.test(richness_growth_data$Mean, richness_growth_data$Richness, use = "pairwise")
summary(lm_MxR)
# By species
lm_MxR_F <- lm(Mean ~ Species + Richness, richness_functional_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR_F)
summary(lm_MxR_F)
# Basically species and isolate currently explain variation well, and richness doesn't. Which doesn't seem right...
lm_anova <- anova(lm_MxR, lm_MxR_F)
growthXrichness_mean
ggplot(richness_growth_data, aes(Richness, Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = TRUE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = TRUE) +
xlab("Mixture Complexity") +
ylab("Mean Growth")
ggplot(richness_growth_data, aes(as.factor(Richness), Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = TRUE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = TRUE) +
xlab("Mixture Complexity") +
ylab("Mean Area Under Curve")
richness_growth_data
ggplot(richness_growth_data, aes(as.factor(Richness), Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD)) +
xlab("Mixture Complexity") +
ylab("Mean Area Under Curve")
ggplot(richness_growth_data, aes(as.factor(Richness), Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_errorbar(ymin = Mean - SD, ymax = Mean + SD) +
xlab("Mixture Complexity") +
ylab("Mean Area Under Curve")
ggplot(richness_growth_data, aes(as.factor(Richness), Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD, colour = Isolate)) +
xlab("Mixture Complexity") +
ylab("Mean Area Under Curve")
ggplot(richness_growth_data, aes(as.factor(Richness), Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD, colour = Isolate, position = position_dodge(width = 0.5))) +
xlab("Mixture Complexity") +
ylab("Mean Area Under Curve")
ggplot(richness_growth_data, aes(as.factor(Richness), Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD, colour = Isolate), position = position_dodge(width = 0.5)) +
xlab("Mixture Complexity") +
ylab("Mean Area Under Curve")
richness_growth_data
ggplot(richness_growth_data, aes(as.factor(Richness), Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_errorbar(aes(ymin = mean(Mean - SD), ymax = mean(Mean + SD), colour = Isolate), position = position_dodge(width = 0.5)) +
xlab("Mixture Complexity") +
ylab("Mean Area Under Curve")
richness_growth_data
richness_growth_data <- richness_growth_data %>%
group_by(Richness, Isolate) %>%
summarise(Mean = mean(Mean), SD = sqrt(sum(SD ^ 2)))
richness_growth_data
growthXrichness_mean <- ggplot(richness_growth_data, aes(as.factor(Richness), Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD, colour = Isolate), position = position_dodge(width = 0.5)) +
xlab("Mixture Complexity") +
ylab("Mean Area Under Curve")
growthXrichness_mean
# Produces a basic plot of mixture complexity against a variety of metrics of growth from Growth_Curve_Loop.R. Prints to pdf.
library(dplyr)
library(tidyverse)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
library(tikzDevice)
library(here)
setwd(here("Scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# Let's graph a bunch of growth parameters against stressor richness
# First things first: transmute stressor presence/absence to a single richness column
richness_growth_data <- tidier_growth_data %>%
select(Richness, Isolate, Mean, SD) %>%
filter(Isolate != "Control")
# and for the sake of completeness
richness_functional_growth_data <- aggregate_functional_groups(tidier_growth_data) %>%
select(Richness, Species, Mean, SD) %>%
filter(Species != "Control")
# More means by richness
richness_growth_data <- richness_growth_data %>%
group_by(Richness, Isolate) %>%
summarise(Mean = mean(Mean), SD = sqrt(sum(SD ^ 2)))
# And graph growth against richness, by species of bacteria
growthXrichness_mean <- ggplot(richness_growth_data, aes(as.factor(Richness), Mean)) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD, colour = Isolate), position = position_dodge(width = 0.5)) +
xlab("Mixture Complexity") +
ylab("Mean Area Under Curve")
growthXfunc_richness_mean <- ggplot(richness_functional_growth_data, aes(as.factor(Richness), Mean)) +
geom_smooth(aes(group = Species, colour = Species), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean Growth by Species") +
xlab("Mixture Complexity") +
ylab("Mean Growth")
# # Same for auc_l
# growthXrichness_auc_l <- ggplot(richness_growth_data, aes(Richness, Growth_auc_l)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("auc_l")
#
# # Same for k (max growth?)
# growthXrichness_k <- ggplot(richness_growth_data, aes(Richness, Growth_k)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ylim(0, 1) + # TODO: What's going on here? More of the Ks ~= 0
#   ggtitle("carrying capacity")
#
# # might as well also do
# growthXrichness_r <- ggplot(richness_growth_data, aes(Richness, Growth_r)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("growth rate")
# We can do some linear modelling later and obtain some idea of the statistical soundness behind our measurements...
pdf("Results/Final_Pipeline/growthXrichness.png", width = 9, height = 6)
# ggarrange(growthXrichness_auc_e, growthXrichness_auc_l, growthXrichness_k, growthXrichness_r, common.legend = TRUE, legend = "right", ncol = 2, nrow = 2)
growthXrichness_mean
dev.off()
dev.off()
# A non-visual measure of fit goodness would also be a good idea
lm_MxR <- lm(Mean ~ Richness + Isolate, richness_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR)
cor.test(richness_growth_data$Mean, richness_growth_data$Richness, use = "pairwise")
summary(lm_MxR)
# By species
lm_MxR_F <- lm(Mean ~ Species + Richness, richness_functional_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR_F)
summary(lm_MxR_F)
# Basically species and isolate currently explain variation well, and richness doesn't. Which doesn't seem right...
lm_anova <- anova(lm_MxR, lm_MxR_F)
growthXfunc_richness_mean
# Load in data from my rangefinding experiment. Plot some growth curves?
library(tidyr)
library(growthcurver)
library(dplyr)
library(stringr)
library(here)
library(ggpubr)
#######################
# Misc counters:
# How about a unique time cutoff
rf_time_cutoff <- 24
rf_read_rate <- 4
# It's still 24 though.
# Make a vector of isolates. This should be the same between rangefinding and actual experiments, but:
# TODO: Check paperwork for plate layouts
isolates_rf_vector <- c("KUE4_10 - S. acidaminiphila", "NUE1_1 - B. simplex", "LUF4_5 - L. rhizovicinus", "NUF1_3 - V. paradoxus",
"KUB5_13 - V. paradoxus", "KUE4_4 - B. simplex", "E. coli OP50", "Nash's Field Soil Community")
names(isolates_rf_vector) <- c("A", "B", "C", "D", "E", "F", "G", "H")
concentrations_mod_vector <- c(0.1, 1, 10, 100, 0.1, 1, 10, 100, 0.1, 1, 10, 100)
names(concentrations_mod_vector) <- c(as.character(seq(1,12)))
concentration_stressor_vector <- c(0.02, 0.002, 0.0000002, 0.000002, 0.000004, 0.000002, 0.001, 0.001, 0)
names(concentration_stressor_vector) <- c("Copper", "Nickel", "Chloramphenicol", "Ampicillin", "Atrazine", "Metaldehyde", "Tebuconazole", "Azoxystrobin", "Control")
# Load in plate .CSVs from a seperate folder using a for loop. Make a tibble to contain the data.
# Make sure your plates are correctly ordered in the wd. You will need leading 0s on your plate numbers for the below loop to read them in order.
rf_growth_data <- tibble()
rangefinding_data <- tibble()
#######################
##### Main Script #####
#######################
setwd(here("Scripts", "Data","Bug_Rangefinding","Working_Dir"))
# Let's load in some plates
for (k in 1:length(dir()))
{
# Grab the sheet name and remove the ".csv"
temp_plate_name <- substr(dir()[k], 1, str_length(dir()[k]) - 4)
temp_plate_df <- read.csv(dir()[k])
# fix a pesky capitalisation mismatch
colnames(temp_plate_df)[1] <- "time"
# turn the reader's odd time format in to something useful
temp_plate_df$time <- as.numeric(substr(temp_plate_df$time, 1, 2))
assign(temp_plate_name, temp_plate_df)
temp_conc_thing <- unname(concentration_stressor_vector[temp_plate_name])
# tidy data
temp_plate_tidy <- as_tibble(temp_plate_df) %>%
gather(well, OD, 2:97) %>%
# Match our premade concentration and isolate vectors rather haphazardly to the first or last character(s) of the location
mutate(stressor = temp_plate_name) %>%
mutate(Concentration = concentrations_mod_vector[substr(well, 2, str_length(well))] * temp_conc_thing) %>%
mutate(Isolate = isolates_rf_vector[substr(well, 1, 1)])
rangefinding_data <- bind_rows(rangefinding_data, temp_plate_tidy)
}
for (l in 1:(nrow(rangefinding_data) / 55))
{
temp_data_growth_0 <-
rangefinding_data[((l-1) * 55):(l * 55),] %>%
filter(time <= rf_time_cutoff) %>%
filter((time %% rf_read_rate) == 0)                                          # Filter your data set down to readings ever n hours
temp_data_growth_1 <- SummarizeGrowth(temp_data_growth_0$time, temp_data_growth_0$OD)        # Generate a logistic model for this well's growth
temp_data_growth_2 <- bind_cols(Growth_auc_e = temp_data_growth_1$vals$auc_e,
Growth_k = temp_data_growth_1$vals$k,
Fit_notes = temp_data_growth_1$vals$note,
Stressor = temp_data_growth_0$stressor[[1]],
Concentration = temp_data_growth_0$Concentration[[1]],
Isolate = temp_data_growth_0$Isolate[[1]])
rf_growth_data <- bind_rows(rf_growth_data, temp_data_growth_2)
}
# Let's make some dose response curves
for (k in 1:8)
{
temp_rangefinding <- rf_growth_data %>%
filter(Stressor == names(concentration_stressor_vector[k])) %>%
group_by(Isolate, Concentration, Stressor) %>%
summarise(Mean_growth = mean(Growth_k))
# (Don't) Add mean growth
# temp_rangefinding <- temp_rangefinding %>%
#   bind_rows(temp_rangefinding %>%
#               group_by(Concentration, Stressor) %>%
#               summarise(Mean_growth = mean(Mean_growth)) %>%
#               mutate(Isolate = "Mean"))
temp_plot_name <- paste("p", k, sep = "")
temp_plot <-
ggplot(data = temp_rangefinding, aes(
x = log(Concentration),
y = log(Mean_growth),
colour = Isolate)) +
geom_point() +
ggtitle(label = names(concentration_stressor_vector[k])) +
geom_smooth(method = "loess", se = FALSE) +
geom_vline(xintercept = log(concentration_stressor_vector[k]), colour = "grey", linetype = "dashed") +
annotate("text",
label = paste("Target concentration = ", concentration_stressor_vector[k], " μg/L", sep = ""),
hjust = 1,
vjust = 1,
color = "grey",
angle = 90) +
theme(legend.position = "none",
axis.title.y = element_blank(),
axis.title.x = element_blank())
assign(temp_plot_name, temp_plot)
}
dummy_legend <- get_legend(
ggplot(data = temp_rangefinding, aes(
x = log(Concentration),
y = Mean_growth,
colour = Isolate)) +
geom_point()
)
setwd(here("Scripts","Results","Bug_Rangefinding"))
pdf("plots_rangefinding.pdf", width = 9, height = 9)
annotate_figure(ggarrange(p1, p2, p3, p4, p5, p6, p7, p8, dummy_legend, ncol = 3, nrow = 3),
left = text_grob("Mean Carrying Capacity (OD)", size = 16, rot = 90),
bottom = text_grob("Log Concentration", size = 16))
dev.off()
dev.off()
annotate_figure(ggarrange(p1, p2, p3, p4, p5, p6, p7, p8, dummy_legend, ncol = 3, nrow = 3),
left = text_grob("Mean Carrying Capacity (OD)", size = 16, rot = 90),
bottom = text_grob("Log Concentration", size = 16))
rf_growth_data
View(rf_growth_data)
rangefinding_data
plot(temp_data_growth_1)
l = 24
temp_data_growth_0 <-
rangefinding_data[((l-1) * 55):(l * 55),] %>%
filter(time <= rf_time_cutoff) %>%
filter((time %% rf_read_rate) == 0)                                          # Filter your data set down to readings ever n hours
temp_data_growth_1 <- SummarizeGrowth(temp_data_growth_0$time, temp_data_growth_0$OD)        # Generate a logistic model for this well's growth
plot(temp_data_growth_1)
l = 23
temp_data_growth_0 <-
rangefinding_data[((l-1) * 55):(l * 55),] %>%
filter(time <= rf_time_cutoff) %>%
filter((time %% rf_read_rate) == 0)                                          # Filter your data set down to readings ever n hours
temp_data_growth_1 <- SummarizeGrowth(temp_data_growth_0$time, temp_data_growth_0$OD)        # Generate a logistic model for this well's growth
plot(temp_data_growth_1)
