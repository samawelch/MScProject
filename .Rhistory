Growth_auc_e = temp_data_growth_1$vals$auc_e,
Growth_auc_l = temp_data_growth_1$vals$auc_l,
Growth_k = temp_data_growth_1$vals$k, # TODO: Change coordinates to colnames.
Growth_r = temp_data_growth_1$vals$r,
Growth_n0 = temp_data_growth_1$vals$n0,
Growth_sigma = temp_data_growth_1$vals$sigma,
Fit_notes = temp_data_growth_1$vals$note,
Copper = temp_data_growth_0$Copper[[1]],
Nickel = temp_data_growth_0$Nickel[[1]],
Chloramphenicol = temp_data_growth_0$Chloramphenicol[[1]],
Ampicillin = temp_data_growth_0$Ampicillin[[1]],
Metaldehyde = temp_data_growth_0$Metaldehyde[[1]],
Atrazine = temp_data_growth_0$Atrazine[[1]],
Tebuconazole = temp_data_growth_0$Tebuconazole[[1]],
Azoxystrobin = temp_data_growth_0$Azoxystrobin[[1]],
Isolate = temp_data_growth_0$Isolate[[1]])
tidy_growth_data <- bind_rows(tidy_growth_data, temp_data_growth_2)
}
#
#
#   # Delete bad fits for the well if we now have a good one
#   tidy_growth_data <- tidy_growth_data %>%
#     filter(((location != temp_data_growth_0$location[[1]]) && (temp_data_growth_1$vals$note != "")))
# append the area under the empirical curve (auc_e, etc. to tidy_growth_data)
# count bad fits
if (temp_data_growth_1$vals$note != "")
{
bad_fit_count = bad_fit_count + 1
}
# Cannabalised for loop to generate a text string of stressors present, to annotate growth curve printouts. Ugly and fragile.
# for (q in 4:11)
# {
#   if (temp_data_growth_0[1,q] == 1)
#   {
#     # If a stressor is present, append it to the cell name
#     temp_well_stressor_list <- paste(temp_well_stressor_list,abbreviate(colnames(temp_data_growth_0[q]), minlength = 2), sep = "")
#   }
# }
# # we can also generate plate curve graphics:
# temp_data_growth_4 <- as.tibble(temp_data_growth_1$data)
# # TODO: Fix this horrible if statement.
# if (is.character(temp_data_growth_1$model) == FALSE)
#   # Apparently if growthcurver can't fit a curve it returns a character instead. This is hardly helpful. So we need an if/else statement to catch these.
# {
#   temp_predict <- data.frame(time = temp_data_growth_0$time, pred.wt = predict(temp_data_growth_1$model, sigma = temp_data_growth_1$model$sigma))
#
#   # Render a temporary plot of the data points and the logistic curve from growthcurver (stored in temp_predict)
#   temp_plot <- ggplot(temp_data_growth_0, aes(x = time, y = OD)) +
#     geom_point() +
#     geom_line(data = temp_predict, aes(x = time, y = pred.wt), colour = "deepskyblue1") +
#     ggtitle(temp_data_growth_2$location) +
#     theme(axis.title.x=element_blank(),
#           axis.ticks.x=element_blank(),
#           axis.title.y=element_blank(),
#           axis.ticks.y=element_blank()) +
#     ylim(0,1) +
#     annotate("text", x = 10, y = 0.5, label = temp_well_stressor_list, colour = "deepskyblue1") +
#     annotate("text", x = 10, y = 0.7, label = temp_data_growth_1$vals$note, colour = "deepskyblue1") +
#     annotate("text", x = 10, y = 0.3, label = temp_data_growth_2$Run, colour = "deepskyblue1")
# }
# else
# {
#   temp_plot <- ggplot(temp_data_growth_0, aes(x = time, y = OD)) +
#     geom_point() +
#     ggtitle(temp_data_growth_2$location) +
#     theme(axis.title.x=element_blank(),
#           axis.ticks.x=element_blank(),
#           axis.title.y=element_blank(),
#           axis.ticks.y=element_blank()) +
#     ylim(0,1) +
#     annotate("text", x = 25, y = 0.5, label = temp_well_stressor_list, colour = "deepskyblue1") +
#     annotate("text", x = 10, y = 0.3, label = temp_data_growth_2$Run, colour = "deepskyblue1")
# }
#
# temp_plot_name <- paste("well_curve", temp_data_growth_2$location, "Run", run_count ,sep = "_")
# assign(temp_plot_name, temp_plot)
# well_curve_plot_vector[[l]] <- temp_plot
# temp_well_stressor_list <- "" # Don't forget to clear it here...
}
# Just to give an idea of how good the fits are...
cat("bad fits: \n", bad_fit_count, "\n")
cat("of total wells: \n", wells_count, "\n")
# Take tidy_growth_data from Growth_Curve_Loop and get cracking on some means and standard deviations
# TODO: Be really, really sure about the difference between SE and SD and which is more appropriate to use here
library(dplyr)
library(tibble)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(growthmodels)
setwd(here("Scripts"))
#######################
### SET INPUTS HERE ###
#######################
# Pick a growth metric. This will be used in all dependent scripts, so choose carefully...
growth_metric <- "Growth_auc_e"
# (UQ(rlang::sym(growth_metric))) notation is used to cleanly insert your chosen growth metric into data manipulation functions
#######################
##### Main Script #####
#######################
# Make a new tibble with a clever name. And a measure of stressor richness.
tidier_growth_data <-
tidy_growth_data %>%
select(location, Growth_auc_e, Growth_auc_l, Growth_k, Growth_r, Growth_n0, Growth_sigma, Fit_notes, Copper, Nickel, Chloramphenicol, Ampicillin, Atrazine, Metaldehyde, Tebuconazole, Azoxystrobin, Isolate) %>%
mutate(Richness = Copper + Nickel + Chloramphenicol + Ampicillin + Atrazine + Metaldehyde + Tebuconazole + Azoxystrobin)
# Pull out our controls so we can average them by Isolate rather than location
temp_control_means <- tidier_growth_data %>%
filter(Richness == 0) %>%
select(-location) %>%
group_by(Isolate) %>%
mutate(Mean = mean(UQ(rlang::sym(growth_metric)))) %>%
mutate(SD = sd(UQ(rlang::sym(growth_metric)))) %>%
mutate(n = n()) %>%
select(-Growth_auc_e, -Growth_auc_l, -Growth_k, -Growth_r, -Growth_n0, -Growth_sigma, -Fit_notes) %>%
distinct() %>% # TODO:  I still don't know a better way to average across rows in one fell swoop
ungroup()
# Average the remaining treatment wells by location
tidier_growth_data <- tidier_growth_data %>%
mutate(Richness = Copper + Nickel + Chloramphenicol + Ampicillin + Atrazine + Metaldehyde + Tebuconazole + Azoxystrobin) %>%
filter(Richness != 0) %>%
group_by(location) %>%
mutate(Mean = mean(UQ(rlang::sym(growth_metric)))) %>%
mutate(SD = sd(UQ(rlang::sym(growth_metric)))) %>%
mutate(n = n()) %>%
select(-Growth_auc_e, -Growth_auc_l, -Growth_k, -Growth_r, -Growth_n0, -Growth_sigma, -Fit_notes) %>%
distinct() %>%
ungroup() %>%
select(-location)
# And merge them back together! Which now that I come to think of it may not be necessary?
tidier_growth_data <- bind_rows(tidier_growth_data, temp_control_means)
# How many problems are we likely to have with poor replication (spoiler: lots)
paste("bad wells", nrow(filter(tidier_growth_data, n == 1)))
paste("total wells", nrow(tidier_growth_data))
# Calculate sample size range for each isolate
sample_size <- tidier_growth_data %>%
group_by(Isolate) %>%
summarise(Mean_n = mean(n), SD_n = sd(n))
write.csv(sample_size, "Results/Final_Pipeline/sample_sizes_table.csv")
# Produces a basic plot of mixture complexity against a variety of metrics of growth from Growth_Curve_Loop.R. Prints to pdf.
# TODO: What's the statistical validity of any of this? How can I best represent it?
# TODO: Figure out the big deal with carrying capacity.
library(dplyr)
library(tidyverse)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
library(tikzDevice)
setwd(here("Scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# Let's graph a bunch of growth parameters against stressor richness
# First things first: transmute stressor presence/absence to a single richness column
richness_growth_data <- tidier_growth_data %>%
select(Richness, Isolate, Mean, SD) %>%
filter(Isolate != "Control")
# and for the sake of completeness
richness_functional_growth_data <- aggregate_functional_groups(tidier_growth_data) %>%
select(Richness, Species, Mean, SD) %>%
filter(Species != "Control")
# And graph growth against richness, by species of bacteria
growthXrichness_mean <- ggplot(richness_growth_data, aes(Richness, Mean)) +
geom_jitter(aes(colour = Isolate, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e")
growthXfunc_richness_mean <- ggplot(richness_functional_growth_data, aes(as.factor(Richness), Mean)) +
geom_smooth(aes(group = Species, colour = Species), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean Growth by Species") +
xlab("Mixture Complexity") +
ylab("Mean Growth")
# # Same for auc_l
# growthXrichness_auc_l <- ggplot(richness_growth_data, aes(Richness, Growth_auc_l)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("auc_l")
#
# # Same for k (max growth?)
# growthXrichness_k <- ggplot(richness_growth_data, aes(Richness, Growth_k)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ylim(0, 1) + # TODO: What's going on here? More of the Ks ~= 0
#   ggtitle("carrying capacity")
#
# # might as well also do
# growthXrichness_r <- ggplot(richness_growth_data, aes(Richness, Growth_r)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("growth rate")
# We can do some linear modelling later and obtain some idea of the statistical soundness behind our measurements...
png("Results/Final_Pipeline/growthXrichness.png", width = 1600, height = 800)
# ggarrange(growthXrichness_auc_e, growthXrichness_auc_l, growthXrichness_k, growthXrichness_r, common.legend = TRUE, legend = "right", ncol = 2, nrow = 2)
growthXfunc_richness_mean
dev.off()
# A non-visual measure of fit goodness would also be a good idea
lm_MxR <- lm(Mean ~ Richness + Isolate, richness_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR)
cor.test(richness_growth_data$Mean, richness_growth_data$Richness, use = "pairwise")
summary(lm_MxR)
# By species
lm_MxR_F <- lm(Mean ~ Species + Richness, richness_functional_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR_F)
summary(lm_MxR_F)
# Basically species and isolate currently explain variation well, and richness doesn't. Which doesn't seem right...
lm_anova <- anova(lm_MxR, lm_MxR_F)
# Let's try tikz
tikz("Results/Final_Pipeline/growthXrichness.tex")
growthXfunc_richness_mean
dev.off()
# Let's try tikz
tikz("Results/Final_Pipeline/growthXrichness.tex", width = 3.5, height = 3.5)
growthXfunc_richness_mean
dev.off()
plot(1,main='Hello World!')
library(tikzDevice)
tikz('figs/simpleEx.tex',width=3.5,height=3.5)
plot(1,main='Hello World!')
dev.off()
library(tikzDevice)
tikz('Results/simpleEx.tex',width=3.5,height=3.5)
plot(1,main='Hello World!')
dev.off()
install.packages(c('tinytex', 'rmarkdown'))
tinytex::install_tinytex()
tikz('Results/simpleEx.tex',width=3.5,height=3.5)
plot(1,main='Hello World!')
library(tikzDevice)
tikz('Results/simpleEx.tex',width=3.5,height=3.5)
plot(1,main='Hello World!')
dev.off()
setwd(here("Scripts"))
library(here)
setwd(here("Scripts"))
library(tikzDevice)
tikz('Results/simpleEx.tex',width=3.5,height=3.5)
plot(1,main='Hello World!')
dev.off()
library(tikzDevice)
ls
library(tikzDevice)
tikz('Results/simpleEx.tex',width=3.5,height=3.5)
plot(1,main='Hello World!')
dev.off()
# Produces a basic plot of mixture complexity against a variety of metrics of growth from Growth_Curve_Loop.R. Prints to pdf.
# TODO: What's the statistical validity of any of this? How can I best represent it?
# TODO: Figure out the big deal with carrying capacity.
library(dplyr)
library(tidyverse)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
library(tikzDevice)
library(here)
setwd(here("Scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# Let's graph a bunch of growth parameters against stressor richness
# First things first: transmute stressor presence/absence to a single richness column
richness_growth_data <- tidier_growth_data %>%
select(Richness, Isolate, Mean, SD) %>%
filter(Isolate != "Control")
# and for the sake of completeness
richness_functional_growth_data <- aggregate_functional_groups(tidier_growth_data) %>%
select(Richness, Species, Mean, SD) %>%
filter(Species != "Control")
# And graph growth against richness, by species of bacteria
growthXrichness_mean <- ggplot(richness_growth_data, aes(Richness, Mean)) +
geom_jitter(aes(colour = Isolate, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e")
growthXfunc_richness_mean <- ggplot(richness_functional_growth_data, aes(as.factor(Richness), Mean)) +
geom_smooth(aes(group = Species, colour = Species), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean Growth by Species") +
xlab("Mixture Complexity") +
ylab("Mean Growth")
# # Same for auc_l
# growthXrichness_auc_l <- ggplot(richness_growth_data, aes(Richness, Growth_auc_l)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("auc_l")
#
# # Same for k (max growth?)
# growthXrichness_k <- ggplot(richness_growth_data, aes(Richness, Growth_k)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ylim(0, 1) + # TODO: What's going on here? More of the Ks ~= 0
#   ggtitle("carrying capacity")
#
# # might as well also do
# growthXrichness_r <- ggplot(richness_growth_data, aes(Richness, Growth_r)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("growth rate")
# We can do some linear modelling later and obtain some idea of the statistical soundness behind our measurements...
png("Results/Final_Pipeline/growthXrichness.png", width = 1600, height = 800)
# ggarrange(growthXrichness_auc_e, growthXrichness_auc_l, growthXrichness_k, growthXrichness_r, common.legend = TRUE, legend = "right", ncol = 2, nrow = 2)
growthXfunc_richness_mean
dev.off()
# A non-visual measure of fit goodness would also be a good idea
lm_MxR <- lm(Mean ~ Richness + Isolate, richness_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR)
cor.test(richness_growth_data$Mean, richness_growth_data$Richness, use = "pairwise")
summary(lm_MxR)
# By species
lm_MxR_F <- lm(Mean ~ Species + Richness, richness_functional_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR_F)
summary(lm_MxR_F)
# Basically species and isolate currently explain variation well, and richness doesn't. Which doesn't seem right...
lm_anova <- anova(lm_MxR, lm_MxR_F)
# Let's try tikz
tikz("Results/Final_Pipeline/growthXrichness.tex", width = 3.5, height = 3.5)
growthXfunc_richness_mean
dev.off()
library(tikzDevice)
tikz('Results/simpleEx.tex',width=3.5,height=3.5)
plot(1,main='Hello World!')
dev.off()
library(tikzDevice)
library(ggplot2)
#For some reason, Rstudio needs to know the time zone...
options(tz="CA")
#Dummy data for the plot
y <- exp(seq(1,10,.1))
x <- 1:length(y)
data <- data.frame(x = x, y = y)
#Create a .tex file that will contain your plot as vectors
#You need to set the size of your plot here, if you do it in LaTeX, font consistency with the rest of the document will be lost
tikz(file = "plot_test.tex", width = 5, height = 5)
#Simple plot of the dummy data using LaTeX elements
plot <- ggplot(data, aes(x = x, y = y)) +
geom_line() +
#Space does not appear after Latex
ggtitle( paste("Fancy \\LaTeX ", "\\hspace{0.01cm} title")) +
labs( x = "$x$ = Time", y = "$\\Phi$ = Innovation output") +
theme_bw()
#This line is only necessary if you want to preview the plot right after compiling
print(plot)
#Necessary to close or the tikxDevice .tex file will not be written
dev.off()
remove.packages('tiksDevice')
remove.packages('tikzDevice')
install.packages("tikzDevice")
library(tikzDevice)
library(ggplot2)
#For some reason, Rstudio needs to know the time zone...
options(tz="CA")
#Dummy data for the plot
y <- exp(seq(1,10,.1))
x <- 1:length(y)
data <- data.frame(x = x, y = y)
#Create a .tex file that will contain your plot as vectors
#You need to set the size of your plot here, if you do it in LaTeX, font consistency with the rest of the document will be lost
tikz(file = "plot_test.tex", width = 5, height = 5)
#Simple plot of the dummy data using LaTeX elements
plot <- ggplot(data, aes(x = x, y = y)) +
geom_line() +
#Space does not appear after Latex
ggtitle( paste("Fancy \\LaTeX ", "\\hspace{0.01cm} title")) +
labs( x = "$x$ = Time", y = "$\\Phi$ = Innovation output") +
theme_bw()
#This line is only necessary if you want to preview the plot right after compiling
print(plot)
#Necessary to close or the tikxDevice .tex file will not be written
dev.off()
getwd()
tikzDevice::tikzTest()
require('tikzDevice')
library(tinytex)
library(tikzDevice)
library(tinytex)
library(ggplot2)
#For some reason, Rstudio needs to know the time zone...
options(tz="CA")
#Dummy data for the plot
y <- exp(seq(1,10,.1))
x <- 1:length(y)
data <- data.frame(x = x, y = y)
#Create a .tex file that will contain your plot as vectors
#You need to set the size of your plot here, if you do it in LaTeX, font consistency with the rest of the document will be lost
tikz(file = "plot_test.tex", width = 5, height = 5)
#Simple plot of the dummy data using LaTeX elements
plot <- ggplot(data, aes(x = x, y = y)) +
geom_line() +
#Space does not appear after Latex
ggtitle( paste("Fancy \\LaTeX ", "\\hspace{0.01cm} title")) +
labs( x = "$x$ = Time", y = "$\\Phi$ = Innovation output") +
theme_bw()
#This line is only necessary if you want to preview the plot right after compiling
print(plot)
#Necessary to close or the tikxDevice .tex file will not be written
dev.off()
setInternet2(TRUE)
library(tikzDevice)
library(ggplot2)
y <- exp(seq(1,10,.1))
x <- 1:length(y)
data <- data.frame(x = x, y = y)
tikz(file = "test.tex")
plot <- ggplot(data, aes(x = x, y = y)) + geom_line()
dev.off()
tikz(file = "test.tex")
ggplot(data, aes(x = x, y = y)) + geom_line()
ggplot(data, aes(x = x, y = y)) + geom_line()
tikzDevice::tikzTest()
Sys.getenv(c("USERPROFILE", "R_USER", "R_LIBS_USER"))
tikz(file = "test.tex")
ggplot(data, aes(x = x, y = y)) + geom_line()
tempfile()
?tempfile()
tempdir()
?tempdir()
tempdir(check = TRUE)
temp()
?startup
Sys.getenv('R_USER')
temp()
tempdir()
# Modifies tidy_data to produce isolate_single_stress, which is limited to growth data by isolate by stressor. Prints to pdf.
# Requires Well_Data_Loader.R, and Growth_Curve_Loop.R
library(dplyr)
library(tibble)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
setwd(here("scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# A colour vector for consistent colouring
stressor_colours <- c("Copper" = "red", "Nickel" = "darkred", "Chloramphenicol" = "darkmagenta", "Ampicillin" = "magenta", "Atrazine" = "green", "Metaldehyde" = "darkgreen", "Tebuconazole" = "blue", "Azoxystrobin" = "darkblue", "None" = "black")
# We can graph the effects of different single stressors on bacteria. For instance:
isolate_single_stress <- tidy_data %>%
filter((Copper + Nickel + Chloramphenicol + Ampicillin + Atrazine + Metaldehyde + Tebuconazole + Azoxystrobin) <= 1) %>%
select(-location) %>%
mutate(Stressor = "None")
# A for loop to turn presence/absence data into a single variable (only works for single stressors). I am not proud of how long this took to implement.
for (m in 1:nrow(isolate_single_stress))
{
for (n in 1:8)
{
if (isolate_single_stress[m,n+3] == 1)
{
isolate_single_stress$Stressor[m] = colnames(isolate_single_stress[,n+3])
}
}
}
# Get rid of the presence/absence stressor data
isolate_single_stress <- isolate_single_stress %>%
select(-Copper, -Nickel, -Chloramphenicol, -Ampicillin, -Metaldehyde, -Atrazine, -Tebuconazole, -Azoxystrobin, -Run)
# Calculates one mean and SD for every combination of isolate, stressor and time point
isolate_single_stress <- isolate_single_stress %>%
group_by(Isolate, Stressor, time) %>%
summarise(Mean_OD = mean(OD), SD_OD = sd(OD), n = n()) %>%
distinct()
# for loop across the 8 isolates to produce a 4x2 lattice of graphs
# TODO: still needs logistic curves fitted
for (o in 1:8)
{
temp_isolate <- isolates_vector[o]
temp_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
theme(legend.position="none") +
ylim(0.04,0.35) +
scale_shape_identity() +
geom_smooth(aes(colour = Stressor), method="loess", se = FALSE) +
ggtitle(isolates_species_vector[o]) +
theme(axis.title.x=element_blank(),
axis.title.y=element_blank()) +
# Add a control line
geom_hline(yintercept = 0.05, colour = "grey")
#scale_colour_manual(values = stressor_colours)
temp_plot_name <- paste("p", o ,sep = "")
assign(temp_plot_name, temp_plot)
}
# Plot a dummy graph so we can get a legend.
dummy_plot <- ggplot(filter(isolate_single_stress, Isolate == temp_isolate), aes(time, Mean_OD)) +
geom_point(aes(colour = Stressor), size = 1, shape = 16, alpha = 1) +
scale_shape_identity() +
geom_smooth(aes(colour = Stressor), method="loess", se = FALSE) +
geom_hline(yintercept = 0.05, colour = "grey")
grob_leg <- get_legend(dummy_plot)
# Arange the plots 4x2 with a shared legend
ss_plots <- ggarrange(p2, p4, p1, p7, p6, p5, p3, p8, grob_leg, ncol = 3, nrow = 3)
# Print to PDF
png("Results/Final_Pipeline/single_stressor_plots.png", width = 1500, height = 1500) # setting onefile to false prevents a blank leading page
ss_plots
dev.off()
setwd(here())
