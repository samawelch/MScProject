lm_vector[j] <- temp_lm$coefficients[2]
}
tibble(isolate = isolates_vector[1:8], coeff = lm_vector)
coeff_tibble <- tibble(isolate = isolates_vector[1:8], coeff = lm_vector)
coeff_tibble
View(coeff_tibble)
library(dplyr)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(here)
setwd(here("Scripts"))
data <- read.csv("Data/Calibration_Curves/CT_Data_Merged.csv")[2:5]
data_meaned <- data %>%
group_by(Isolate, Dilution) %>%
summarise(Mean.Count = mean(Cell.Count), Mean.OD = mean(OD))
ggplot(data_meaned, aes(x = Mean.OD, y = Mean.Count, colour = Isolate)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
lm_vector <- vector(length = 8)
for (j in 1:8)
{
temp_lm <- lm(formula = OD ~ Cell.Count, data = filter(data, Isolate == isolates_vector[j]))
temp_lm_name <- paste("lm", j, sep = "")
assign(temp_lm_name, temp_lm)
lm_vector[j] <- temp_lm$coefficients[2]
}
coeff_tibble <- tibble(isolate = isolates_vector[1:8], coeff = lm_vector)
library(dplyr)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(here)
setwd(here("Scripts"))
data <- read.csv("Data/Calibration_Curves/CT_Data_Merged.csv")[2:5]
data_meaned <- data %>%
group_by(Isolate, Dilution) %>%
summarise(Mean.Count = mean(Cell.Count), Mean.OD = mean(OD))
ggplot(data_meaned, aes(x = Mean.OD, y = Mean.Count, colour = Isolate)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
lm_vector <- vector(length = 8)
for (j in 1:8)
{
temp_lm <- lm(formula = OD ~ Cell.Count, data = filter(data, Isolate == isolates_vector[j]))
temp_lm_name <- paste("lm", j, sep = "")
assign(temp_lm_name, temp_lm)
lm_vector[j] <- round(temp_lm$coefficients[2], 2)
}
coeff_tibble <- tibble(isolate = isolates_vector[1:8], coeff = lm_vector)
library(dplyr)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(here)
setwd(here("Scripts"))
data <- read.csv("Data/Calibration_Curves/CT_Data_Merged.csv")[2:5]
data_meaned <- data %>%
group_by(Isolate, Dilution) %>%
summarise(Mean.Count = mean(Cell.Count), Mean.OD = mean(OD))
ggplot(data_meaned, aes(x = Mean.OD, y = Mean.Count, colour = Isolate)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
lm_vector <- vector(length = 8)
for (j in 1:8)
{
temp_lm <- lm(formula = OD ~ Cell.Count, data = filter(data, Isolate == isolates_vector[j]))
temp_lm_name <- paste("lm", j, sep = "")
assign(temp_lm_name, temp_lm)
lm_vector[j] <- temp_lm$coefficients[2]
}
coeff_tibble <- tibble(isolate = isolates_vector[1:8], coeff = lm_vector)
isolates_vector
?order
coeff_tibble <- order(tibble(isolate = isolates_vector[1:8], coeff = lm_vector), isolates_vector[1:8]
library(dplyr)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(here)
setwd(here("Scripts"))
data <- read.csv("Data/Calibration_Curves/CT_Data_Merged.csv")[2:5]
data_meaned <- data %>%
group_by(Isolate, Dilution) %>%
summarise(Mean.Count = mean(Cell.Count), Mean.OD = mean(OD))
ggplot(data_meaned, aes(x = Mean.OD, y = Mean.Count, colour = Isolate)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
lm_vector <- vector(length = 8)
for (j in 1:8)
{
temp_lm <- lm(formula = OD ~ Cell.Count, data = filter(data, Isolate == isolates_vector[j]))
temp_lm_name <- paste("lm", j, sep = "")
assign(temp_lm_name, temp_lm)
lm_vector[j] <- temp_lm$coefficients[2]
}
coeff_tibble <- order(tibble(isolate = isolates_vector[1:8], coeff = lm_vector), isolates_vector[1:8])
isolates_vector[1:8]
coeff_tibble <- order(isolates_vector[1:8], tibble(isolate = isolates_vector[1:8], coeff = lm_vector))
ggplot(data_meaned, aes(x = Mean.OD, y = Mean.Count, colour = Isolate)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
temp_lm$coefficients
library(dplyr)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(here)
setwd(here("Scripts"))
data <- read.csv("Data/Calibration_Curves/CT_Data_Merged.csv")[2:5]
data_meaned <- data %>%
group_by(Isolate, Dilution) %>%
summarise(Mean.Count = mean(Cell.Count), Mean.OD = mean(OD))
ggplot(data_meaned, aes(x = Mean.OD, y = Mean.Count, colour = Isolate)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
lm_vector <- vector(length = 8)
for (j in 1:8)
{
temp_lm <- lm(formula = OD ~ Cell.Count, data = filter(data, Isolate == isolates_vector[j]))
temp_lm_name <- paste("lm", j, sep = "")
assign(temp_lm_name, temp_lm)
lm_vector[j] <- temp_lm$coefficients[1]
}
coeff_tibble <- tibble(isolate = isolates_vector[1:8], coeff = lm_vector)
library(dplyr)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(here)
setwd(here("Scripts"))
data <- read.csv("Data/Calibration_Curves/CT_Data_Merged.csv")[2:5]
data_meaned <- data %>%
group_by(Isolate, Dilution) %>%
summarise(Mean.Count = mean(Cell.Count), Mean.OD = mean(OD))
ggplot(data_meaned, aes(x = Mean.OD, y = Mean.Count, colour = Isolate)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
lm_vector <- vector(length = 8)
for (j in 1:8)
{
temp_lm <- lm(formula = Cell.Count ~ OD, data = filter(data, Isolate == isolates_vector[j]))
temp_lm_name <- paste("lm", j, sep = "")
assign(temp_lm_name, temp_lm)
lm_vector[j] <- temp_lm$coefficients[1]
}
coeff_tibble <- tibble(isolate = isolates_vector[1:8], coeff = lm_vector)
temp_lm
# Produces a basic plot of mixture complexity against a variety of metrics of growth from Growth_Curve_Loop.R. Prints to pdf.
# TODO: What's the statistical validity of any of this? How can I best represent it?
# TODO: Figure out the big deal with carrying capacity.
library(dplyr)
library(tidyverse)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(ggpubr)
setwd(here("Scripts"))
source('Code/Final_Pipeline/Function_Aggregate_Fun_Groups.R')
# Let's graph a bunch of growth parameters against stressor richness
# First things first: transmute stressor presence/absence to a single richness column
richness_growth_data <- tidier_growth_data %>%
select(Richness, Isolate, Mean, SD) %>%
filter(Isolate != "Control")
# and for the sake of completeness
richness_functional_growth_data <- aggregate_functional_groups(tidier_growth_data) %>%
select(Richness, Species, Mean, SD) %>%
filter(Species != "Control")
# And graph growth against richness, by species of bacteria
growthXrichness_mean <- ggplot(richness_growth_data, aes(Richness, Mean)) +
geom_jitter(aes(colour = Isolate, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e")
growthXfunc_richness_mean <- ggplot(richness_functional_growth_data, aes(as.factor(Richness), Mean)) +
geom_jitter(aes(colour = Species, shape = 16), width = 0.3) +
scale_shape_identity() +
geom_smooth(aes(group = Species, colour = Species), method = "lm", se = FALSE) +
geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
ggtitle("Mean auc_e by Species")
# # Same for auc_l
# growthXrichness_auc_l <- ggplot(richness_growth_data, aes(Richness, Growth_auc_l)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("auc_l")
#
# # Same for k (max growth?)
# growthXrichness_k <- ggplot(richness_growth_data, aes(Richness, Growth_k)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ylim(0, 1) + # TODO: What's going on here? More of the Ks ~= 0
#   ggtitle("carrying capacity")
#
# # might as well also do
# growthXrichness_r <- ggplot(richness_growth_data, aes(Richness, Growth_r)) +
#   geom_point(aes(colour = Isolate, shape = 1)) +
#   scale_shape_identity() +
#   geom_smooth(aes(group = Isolate, colour = Isolate), method = "lm", se = FALSE) +
#   geom_smooth(aes(colour = "Overall"), method = "lm", se = FALSE) +
#   ggtitle("growth rate")
# We can do some linear modelling later and obtain some idea of the statistical soundness behind our measurements...
png("Results/Final_Pipeline/growthXrichness.png", width = 1600, height = 800)
# ggarrange(growthXrichness_auc_e, growthXrichness_auc_l, growthXrichness_k, growthXrichness_r, common.legend = TRUE, legend = "right", ncol = 2, nrow = 2)
growthXfunc_richness_mean
dev.off()
# A non-visual measure of fit goodness would also be a good idea
lm_MxR <- lm(Mean ~ Richness + Isolate, richness_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR)
cor.test(richness_growth_data$Mean, richness_growth_data$Richness, use = "pairwise")
summary(lm_MxR)
# By species
lm_MxR_F <- lm(Mean ~ Species + Richness, richness_functional_growth_data)
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 1.5))
plot(lm_MxR_F)
summary(lm_MxR_F)
# Basically species and isolate currently explain variation well, and richness doesn't. Which doesn't seem right...
lm_anova <- anova(lm_MxR, lm_MxR_F)
setwd(here())
# Take tidy_growth_data from Growth_Curve_Loop and get cracking on some means and standard deviations
# TODO: Be really, really sure about the difference between SE and SD and which is more appropriate to use here
library(dplyr)
library(tibble)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(growthmodels)
#######################
### SET INPUTS HERE ###
#######################
# Pick a growth metric. This will be used in all dependent scripts, so choose carefully...
growth_metric <- "Growth_auc_e"
# (UQ(rlang::sym(growth_metric))) notation is used to cleanly insert your chosen growth metric into data manipulation functions
#######################
##### Main Script #####
#######################
# Make a new tibble with a clever name. And a measure of stressor richness.
tidier_growth_data <-
tidy_growth_data %>%
select(location, Growth_auc_e, Growth_auc_l, Growth_k, Growth_r, Growth_n0, Growth_sigma, Fit_notes, Copper, Nickel, Chloramphenicol, Ampicillin, Atrazine, Metaldehyde, Tebuconazole, Azoxystrobin, Isolate) %>%
mutate(Richness = Copper + Nickel + Chloramphenicol + Ampicillin + Atrazine + Metaldehyde + Tebuconazole + Azoxystrobin)
# Pull out our controls so we can average them by Isolate rather than location
temp_control_means <- tidier_growth_data %>%
filter(Richness == 0) %>%
select(-location) %>%
group_by(Isolate) %>%
mutate(Mean = mean(UQ(rlang::sym(growth_metric)))) %>%
mutate(SD = sd(UQ(rlang::sym(growth_metric)))) %>%
mutate(n = n()) %>%
select(-Growth_auc_e, -Growth_auc_l, -Growth_k, -Growth_r, -Growth_n0, -Growth_sigma, -Fit_notes) %>%
distinct() %>% # TODO:  I still don't know a better way to average across rows in one fell swoop
ungroup()
# Average the remaining treatment wells by location
tidier_growth_data <- tidier_growth_data %>%
mutate(Richness = Copper + Nickel + Chloramphenicol + Ampicillin + Atrazine + Metaldehyde + Tebuconazole + Azoxystrobin) %>%
filter(Richness != 0) %>%
group_by(location) %>%
mutate(Mean = mean(UQ(rlang::sym(growth_metric)))) %>%
mutate(SD = sd(UQ(rlang::sym(growth_metric)))) %>%
mutate(n = n()) %>%
select(-Growth_auc_e, -Growth_auc_l, -Growth_k, -Growth_r, -Growth_n0, -Growth_sigma, -Fit_notes) %>%
distinct() %>%
ungroup() %>%
select(-location)
# And merge them back together! Which now that I come to think of it may not be necessary?
tidier_growth_data <- bind_rows(tidier_growth_data, temp_control_means)
# How many problems are we likely to have with poor replication (spoiler: lots)
paste("bad wells", nrow(filter(tidier_growth_data, n == 1)))
paste("total wells", nrow(tidier_growth_data))
# Calculate sample size range for each isolate
sample_size <- tidier_growth_data %>%
group_by(Isolate) %>%
summarise(Mean_n = mean(n), SD_n = sd(n))
write.csv(sample_size, "Results/Final_Pipeline/sample_sizes_table.csv")
# Loads modified Synergy 2 well data as CSVs from Run_X folders. Compiles into a tidy dataset of OD by time, well, stressor presence/absence and isolate.
# Also implements a number of counters needed by future for loops. Can (theoretically) handle as many replicates as needed.
library(dplyr)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(here)
setwd(here("Scripts")) # Hopefully a slighly more rational way to handle WDs. Run here() for project directory.
# See https://www.rdocumentation.org/packages/here/versions/0.1 for here package documentations.
#Start from a tabula rasa
rm(list=ls())
#######################
### SET INPUTS HERE ###
#######################
# How many timepoints does your data have?
read_timepoints <- 49
# This is no longer usable for a bncuh of stuff because runs 4 & 5 only read every 4 hours
# Every how many hours do we want to take a reading?
read_rate <- 4
# Which ones do we actually want to include
runs_vector <- c(2,3,4,5)
# Load in the plate layout csv for combination and isolate location data
plate_layout <- read.csv("Data/Final_Pipeline/256comb_8bact_plate.csv") %>%
unite(loc, Dest.Row, Dest.Column, sep = "") %>%
unite(location, loc, plate, sep = ".")
#######################
# Misc counters:
# How many plates are there?
plate_count = 0
# How many of the growth curves are bad or questionable fits?
bad_fit_count = 0
# Make a vector of isolates
isolates_vector <- as.vector(unique(plate_layout$Isolate))
isolates_species_vector <- c("KUE4_10 - S. acidaminiphila", "NUE1_1 - B. simplex", "LUF4_5 - L. rhizovicinus", "NUF1_3 - V. paradoxus", "KUB5_13 - V. paradoxus", "KUE4_4 - B. simplex", "E. coli OP50", "Nash's Field Soil Community")
# Make a vector of stressors
stressors_vector <- as.vector(colnames(plate_layout[1:8]))
stressors_vector_short <- abbreviate(stressors_vector, minlength = 2)
# Load in plate .CSVs from a seperate folder using a for loop. Make a tibble to contain the data.
# Make sure your plates are correctly ordered in the wd. You will need leading 0s on your plate numbers for the below loop to read them in order.
tidy_data <- tibble()
#######################
##### Main Script #####
#######################
load_run_data <- function(run_number)
{
# run_number is just the run number, as an integer. Your run folders should be in the format "Run_X", with the .csvs in a nested folder "csvs"
setwd(here("Scripts", "Data", "Final_Pipeline", paste("Run_", run_number, sep = ""), "csvs"))
for (k in 1:length(dir()))
{
# Make a df for each plate with a numbered name & pad plate names with leading 0s so R orders them properly
temp_plate_name <- paste("plate", str_pad(k, 2, pad = "0") ,sep = "_")
temp_plate_df <- read.csv(dir()[k])
# fix a pesky capitalisation mismatch
colnames(temp_plate_df)[1] <- "time"
# turn the reader's odd time format in to something useful
temp_plate_df$time <- as.numeric(substr(temp_plate_df$time, 1, 2))
# turn the reader's odd time format in to something useful
# trim down each well to the number of time points set in read_timepoints
temp_plate_df <- filter(temp_plate_df, time <= read_timepoints)
temp_plate_width <- 97
# we need to remove the last 32 wells from every third plate. This is complicated because it's rows 9,10,11 & 12...
if ((k %% 3) == 0)
{
temp_plate_df <- temp_plate_df %>%
select(-contains("9")) %>%
select(-contains("10")) %>%
select(-contains("11")) %>%
select(-contains("12"))
temp_plate_width <- 65 # if it's a third plate it'll have 64 wells (and thus 65 columns including time)
}
assign(temp_plate_name, temp_plate_df)                         # turn our temporary df into a real df with a for-loop-generated name
# let's also make a massive tidy dataset that's better able to store stressor presence/absence and isolate species
temp_plate_tidy <- as.tibble(temp_plate_df) %>%
gather(well, OD, 2:temp_plate_width) %>%                       # gather the data from wide to tall
mutate(plate = k) %>%                            # add a plate column based on where we are in the for loop
unite(location, well, plate, sep = ".") %>%      # bring the location naming scheme in line with plate_layout
mutate(Run = run_number)
tidy_data <<- bind_rows(tidy_data, temp_plate_tidy)       # add the temporary data to our massive dataset (global assign as we're now in a function)
plate_count <<- plate_count + 1
}
}
# Load run data per run and append it to tidy_data. Starts at 2, because Run 1 was a write-off.
for (r in runs_vector)
{
load_run_data(r)
}
setwd(here("Scripts"))
# Join isolate/stressor data to growth data by observations
tidy_data <- left_join(tidy_data, plate_layout, by = "location")
# If we filter reads down to every 4 hours here we can save some thinking in Growth_Curve_Loop.R
tidy_data <- tidy_data %>%
filter((time %% read_rate) == 0)
# Now:
timepoints_count <- 13
# A few checks
glimpse(tidy_data)
# How many time points do we have?
timepoints_count <- length(unique(tidy_data$time))  # should be 49
timepoints_count
# How many wells do we have? this is wrong for runs 4 & 5
wells_count <- nrow(tidy_data) / timepoints_count # run count * 2144
wells_count
# How many plates
plate_count
setwd(here())
remove.packages("drc")
remove.packages("MASS")
MASS
# Loads modified Synergy 2 well data as CSVs from Run_X folders. Compiles into a tidy dataset of OD by time, well, stressor presence/absence and isolate.
# Also implements a number of counters needed by future for loops. Can (theoretically) handle as many replicates as needed.
library(dplyr)
library(tidyr)
library(ggplot2)
library(growthcurver)
library(gridBase)
library(gridExtra)
library(here)
setwd(here("Scripts")) # Hopefully a slighly more rational way to handle WDs. Run here() for project directory.
# See https://www.rdocumentation.org/packages/here/versions/0.1 for here package documentations.
#Start from a tabula rasa
rm(list=ls())
#######################
### SET INPUTS HERE ###
#######################
# How many timepoints does your data have?
read_timepoints <- 49
# This is no longer usable for a bncuh of stuff because runs 4 & 5 only read every 4 hours
# Every how many hours do we want to take a reading?
read_rate <- 4
# Which ones do we actually want to include
runs_vector <- c(2,3,4,5)
# Load in the plate layout csv for combination and isolate location data
plate_layout <- read.csv("Data/Final_Pipeline/256comb_8bact_plate.csv") %>%
unite(loc, Dest.Row, Dest.Column, sep = "") %>%
unite(location, loc, plate, sep = ".")
#######################
# Misc counters:
# How many plates are there?
plate_count = 0
# How many of the growth curves are bad or questionable fits?
bad_fit_count = 0
# Make a vector of isolates
isolates_vector <- as.vector(unique(plate_layout$Isolate))
isolates_species_vector <- c("KUE4_10 - S. acidaminiphila", "NUE1_1 - B. simplex", "LUF4_5 - L. rhizovicinus", "NUF1_3 - V. paradoxus", "KUB5_13 - V. paradoxus", "KUE4_4 - B. simplex", "E. coli OP50", "Nash's Field Soil Community")
# Make a vector of stressors
stressors_vector <- as.vector(colnames(plate_layout[1:8]))
stressors_vector_short <- abbreviate(stressors_vector, minlength = 2)
# Load in plate .CSVs from a seperate folder using a for loop. Make a tibble to contain the data.
# Make sure your plates are correctly ordered in the wd. You will need leading 0s on your plate numbers for the below loop to read them in order.
tidy_data <- tibble()
#######################
##### Main Script #####
#######################
load_run_data <- function(run_number)
{
# run_number is just the run number, as an integer. Your run folders should be in the format "Run_X", with the .csvs in a nested folder "csvs"
setwd(here("Scripts", "Data", "Final_Pipeline", paste("Run_", run_number, sep = ""), "csvs"))
for (k in 1:length(dir()))
{
# Make a df for each plate with a numbered name & pad plate names with leading 0s so R orders them properly
temp_plate_name <- paste("plate", str_pad(k, 2, pad = "0") ,sep = "_")
temp_plate_df <- read.csv(dir()[k])
# fix a pesky capitalisation mismatch
colnames(temp_plate_df)[1] <- "time"
# turn the reader's odd time format in to something useful
temp_plate_df$time <- as.numeric(substr(temp_plate_df$time, 1, 2))
# turn the reader's odd time format in to something useful
# trim down each well to the number of time points set in read_timepoints
temp_plate_df <- filter(temp_plate_df, time <= read_timepoints)
temp_plate_width <- 97
# we need to remove the last 32 wells from every third plate. This is complicated because it's rows 9,10,11 & 12...
if ((k %% 3) == 0)
{
temp_plate_df <- temp_plate_df %>%
select(-contains("9")) %>%
select(-contains("10")) %>%
select(-contains("11")) %>%
select(-contains("12"))
temp_plate_width <- 65 # if it's a third plate it'll have 64 wells (and thus 65 columns including time)
}
assign(temp_plate_name, temp_plate_df)                         # turn our temporary df into a real df with a for-loop-generated name
# let's also make a massive tidy dataset that's better able to store stressor presence/absence and isolate species
temp_plate_tidy <- as.tibble(temp_plate_df) %>%
gather(well, OD, 2:temp_plate_width) %>%                       # gather the data from wide to tall
mutate(plate = k) %>%                            # add a plate column based on where we are in the for loop
unite(location, well, plate, sep = ".") %>%      # bring the location naming scheme in line with plate_layout
mutate(Run = run_number)
tidy_data <<- bind_rows(tidy_data, temp_plate_tidy)       # add the temporary data to our massive dataset (global assign as we're now in a function)
plate_count <<- plate_count + 1
}
}
# Load run data per run and append it to tidy_data. Starts at 2, because Run 1 was a write-off.
for (r in runs_vector)
{
load_run_data(r)
}
setwd(here("Scripts"))
# Join isolate/stressor data to growth data by observations
tidy_data <- left_join(tidy_data, plate_layout, by = "location")
# If we filter reads down to every 4 hours here we can save some thinking in Growth_Curve_Loop.R
tidy_data <- tidy_data %>%
filter((time %% read_rate) == 0)
# Now:
timepoints_count <- 13
# A few checks
glimpse(tidy_data)
# How many time points do we have?
timepoints_count <- length(unique(tidy_data$time))  # should be 49
timepoints_count
# How many wells do we have? this is wrong for runs 4 & 5
wells_count <- nrow(tidy_data) / timepoints_count # run count * 2144
wells_count
# How many plates
plate_count
setwd(here())
?select
