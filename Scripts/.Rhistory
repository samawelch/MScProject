dd=read.table("Data/bell_rndpartitions.txt",header=T)
dd=dd[,1:(ncol(dd)-3)]
#nb randomise here
#dd.randomise=sample(size=nrow(dd),x=1:nrow(dd),replace=FALSE)
#dd=dd[dd.randomise,]
#richness = number of species per microcosm
richness=rowSums(dd)
#n.sp = number of species in the pool of available species
n.sp=ncol(dd)
#n.microcosms = number of microcosms
n.microcosms=nrow(dd)
#volume in the source plate
vol.source=1000
#volume required per isolate
vol.per.isolate=c()
for(i in 1:n.sp){
vol.per.isolate=c(vol.per.isolate,sum((1/richness)*24*10*dd[,i]))
}
#get number of destination plates
n.dest.plates=nrow(dd)/60 #nb /60 because we're just using the central wells
#if number of destination plates is an integer, remove the decimal part and add one
if(all.equal(nrow(dd)/60,as.integer(nrow(dd)/60))==FALSE){
n.dest.plates=(as.integer(nrow(dd)/60)+1)}
#make sure it's an integer
n.dest.plates=as.integer(n.dest.plates)
#nb using only central wells
destination.rows=rep(rep(LETTERS[2:7],10),n.dest.plates)
destination.cols=rep(rep(2:11,each=6),n.dest.plates)
destination.plate=rep(1:n.dest.plates,each=60)
#define destination plates using every well of 4 destination plates
source.rows=rep(rep(LETTERS[1:8],12),4)
source.cols=rep(rep(1:12,each=8),4)
source.plate=rep(1:4,each=96)
#reps.sp = number of times the species is replicated in the source plate
reps.sp=16
#number of wells of each isolate required in the experiment. Allow 30% extra (so *1.3)
#reps.sp=as.integer((vol.per.isolate/vol.source)*1.4)+1
#sp.start = well in source plate where the species starts.
sp.start=seq(from=1,to=(1+n.sp*max(reps.sp)),by=max(reps.sp))
#source.plate.layout = layout of the source plates
temp=matrix(NA,ncol=12,nrow=8);rownames(temp)=LETTERS[1:8];colnames(temp)=1:12
source.plate.layout=list(temp,temp,temp,temp)
source.plate.sequence=rep(1:n.sp,each=max(reps.sp))
for(i in 1:4){
source.plate.layout[[i]][1:8,]=source.plate.sequence[(((i-1)*96)+1):(((i)*96))]
}
source.plate.layout
#counter=1 #old
#source.increment=0 #old
#source.volume tracker holds the volume remaining in each well, with a separate volume tracker for each isolate
source.volume.tracker=matrix(vol.source,nrow=n.sp,ncol=1)
#source.increment is a counter that keeps track of how many source wells we've gone through for each isolate
source.increment=matrix(0,nrow=n.sp,ncol=1)
#worklist holds the worklist that will be fed into Darth
worklist=c()
#loop through the i each microcosm
for(i in 1:nrow(dd)){
#identify which isolates are in the microcosm
sp=which(dd[i,]==1)
#vol.i = volume of ith microcosm
vol.i=(1/richness[i])*24*10
#loop through each species in the microcosm
for(j in 1:length(sp)){
#add volume to sp[j] source.volume.tracker
source.volume.tracker[sp[j]]=source.volume.tracker[sp[j]]-vol.i
#check to see if we have only 10% of the volume remaining; if so, move to next source well and reset the volume tracker
if(source.volume.tracker[sp[j]]<=250){
source.increment[sp[j]]=source.increment[sp[j]]+1
source.volume.tracker[sp[j]]=vol.source-vol.i
}
worklist=rbind(worklist,c(
source.plate[sp.start[sp[j]]+source.increment[sp[j]]],
source.rows[sp.start[sp[j]]+source.increment[sp[j]]],
source.cols[sp.start[sp[j]]+source.increment[sp[j]]],
destination.plate[i],
destination.rows[i],
destination.cols[i],
(1/richness[i])*24*10)
)
}
if(max(source.increment)>min(reps.sp)){print("WARNING: you have insufficient replication of your source isolates!!")}
}
colnames(worklist)=c("source.plate","source.row","source.column","destination.plate","destination.row","destination.column","vol.ul")
worklist=as.data.frame(worklist)
tapply(as.numeric(as.matrix(worklist$vol.ul)),INDEX=list(worklist$source.row,worklist$source.column,worklist$source.plate),FUN=function(x){sum(x,na.rm=T)})
write.csv(worklist,"Results/worklist-invasion_expt_15-06-2018.csv")
#media worklist
outer.rows=c(rep(LETTERS[1],12),rep(LETTERS[2:7],each=2),rep(LETTERS[8],12))
outer.cols=c(1:12,rep(c(1,12),6),1:12)
dest.plates=1:n.dest.plates
media.rows=rep(outer.rows,n.dest.plates)
media.cols=rep(outer.cols,n.dest.plates)
media.plates=rep(dest.plates,each=length(outer.rows))
media.worklist=cbind(media.plates,media.rows,media.cols,rep(240,length(media.cols)))
colnames(media.worklist)=c("destination.plate","destination.row","destination.column","media.vol.ul")
write.csv(media.worklist,file="Results/media-worklist-expt_16-05-2018.csv")
# Sam Welch
# A script that produces a unique stressor combination ID, fills in a binary matrix based on it, then generates dummy growth data.
# 26th May 2018
rm(list=ls())
library(tidyverse)
library(ggplot2)
library(pwr)
vector_stressors <- c("1","2","3","4","5","6","7","8")
# Generate matrices of every 1-, 2-, 4-, and 8- combination of stressors.
matrix_combn_eight <- combn(vector_stressors,8)
matrix_combn_seven <- combn(vector_stressors,7)
matrix_combn_six <- combn(vector_stressors,6)
matrix_combn_five <- combn(vector_stressors,5)
matrix_combn_four <- combn(vector_stressors,4)
matrix_combn_three <- combn(vector_stressors,3)
matrix_combn_two <- combn(vector_stressors,2)
matrix_combn_one <- combn(vector_stressors,1)
# Turn matrices into vectors of strings of combinations
vector_combn_eight <- apply(matrix_combn_eight,2, paste, collapse="")
vector_combn_seven <- apply(matrix_combn_seven,2, paste, collapse="")
vector_combn_six <- apply(matrix_combn_six,2, paste, collapse="")
vector_combn_five <- apply(matrix_combn_five,2, paste, collapse="")
vector_combn_four <- apply(matrix_combn_four,2, paste, collapse="")
vector_combn_three <- apply(matrix_combn_three,2, paste, collapse="")
vector_combn_two <- apply(matrix_combn_two,2, paste, collapse="")
vector_combn_one <- apply(matrix_combn_one,2, paste, collapse="")
# Combine them into one vector of length 107
vector_combn <- c(vector_combn_one, vector_combn_two, vector_combn_three, vector_combn_four, vector_combn_five, vector_combn_six, vector_combn_seven, vector_combn_eight)
# Create a tibble of unique combination IDs, presence/absence of stressors and five replicates of growth
comb_tibble <- tibble(
vector_combn,
species = 0,
legacy = 0,
`s1` = 0,
`s2` = 0,
`s3` = 0,
`s4` = 0,
`s5` = 0,
`s6` = 0,
`s7` = 0,
`s8` = 0,
`GrowthA` = 0,
`GrowthB` = 0,
`GrowthC` = 0,
`GrowthD` = 0,
`GrowthE` = 0
)
# Loop over all combination IDs and assign stressors as present
# Yes, I am aware of the inefficiency here - I just don't know how to do it better.
for (i in 1:255) {
comb <- comb_tibble[i,1]            # For each combination ID: assign to the variable comb
for (j in 1:8) {                    # Loop across comb for j = 1:8
if (grepl(toString(j),comb)) {    # if comb contains the string of j,
comb_tibble[i, j + 3] = 1    # change the value in the relevant position of the tibble to 1
}
j <- j + 1
}
i <- i + 1
}
# Another loop to stick some random data into the growth columns. Can this be done more elegantly with apply?
for (k in 1:255) {
for (l in 12:16){
comb_tibble[k,l] = runif(1, min=0, max=100)
l <- l + 1
}
k <- k + 1
}
# Add a means column.
summary(comb_tibble)
comb_tibble <- mutate(comb_tibble,GrowthAvg = rowMeans(comb_tibble[,12:16]))
# What I've read online suggests a multiple linear regression or a non-linear multiple regression - so I'm going to try both...
# Multiple linear regression
mlr <- lm(
formula = GrowthAvg ~ s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8,
data = comb_tibble)
summary(mlr)
plot(mlr)
lm0=lm(growth~s1+s2+s3)
lm1=lm(growth~s1+s2+s3+s1:s2+s1:s3+s2:s3)
lm2=lm(growth~s1+s2+s3+s1:s2+s1:s3+s2:s3+s1:s2:s3)
anova(lm0,lm1,lm2)
stepAIC(lm2)
# Make your life easier by automating your X-way interaction formulae
as.formula(c("growth~",paste("s",1:10, sep="")))
# Iterate for each species - do we get the same answers? How would you illustate this?
# We also want to know if there are groups of stressors that are acting similarly:
# hyp: synergy between stressors from different functional groups, etc. -  need to lit search this...
# e.g. negative interactions on growth when they're from the same functional group?
# I can't remember how to interpret any of this, but at least I'll have a choice when it comes to working with the real data...
# Non-linear multiple regression - doesn't work because I don't understand it...
# nlmr <- nls(
#  formula = GrowthAvg ~ s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8, # This is the wrong sort of formula for nls()
#  data = comb_tibble)
# Boxplot of average growth by stressor
comb_tibble_tidy <- gather(comb_tibble, Rep, Growth, 12:16) # Gathering the data for a boxplot of all stressors containing s1
ggplot(
subset(comb_tibble_tidy, s1 = 1),
aes(
x = vector_combn,
y = Growth
)) + geom_boxplot()
# Run an ANOVA/ANCOVA?
anova(mlr)
# Power Analysis?
pwr.anova.test(k = 255, n=4, power = 0.1)
View(comb_tibble)
View(comb_tibble)
write.csv(file = "comb_tibble.csv", comb_tibble[4:11])
#dd = design matrix dataframe (read in)
#richness = richness of each microcosm
#n.sp = number of isolates in the pool of available species
#vol.source = volume of liquid in the source plates
#vol.per.isolate = calculated volume required per species for the experiment as a whole
#n.dest.plates = calculated number of destination plates required in the experiment as a whole
#n.microcosms =  number of microcosms in the experiment
#destination.rows = vector of length n.microcosms that holds the row of each microcosm.
#destination.cols = vector of length n.microcosms that holds the column of each microcosm.
#destination.plate = vector of length n.microcosms that holds the plate number of each microcosm.
#source.rows =  vector of length 384 that holds the row of each source species
#source.cols =  vector of length 384 that holds the row of each source species
#source.plate =  vector of length 384 that holds the row of each source species
#source.plate.layout = layout of each source plate showing location of each isolate
#source.volume.tracker = vector of length n.sp which holds the volume remaining in the source well currently being used, with starting volume of vol.source
#source.increment = vector of length n.sp. If all of the liquid is used up according to source.volume.tracker for species X, source.increment for X increases by one, which shifts the well being used as the source well for X over by one.
#worklist = holds the main worklist
#outer.rows = defines the outer rows of each destination plate
#outer.cols = defines the outer columns of each destination plate
#media.worklist = holds the main media worklist
rm(list=ls())
setwd("C:/Users/Sam Welch/Google Drive/ICL Ecological Applications/Project/Work/Scripts")
dd=read.table("Data/comb_tibble.txt",header=T)
dd=dd[,1:(ncol(dd)-3)]
#nb randomise here
#dd.randomise=sample(size=nrow(dd),x=1:nrow(dd),replace=FALSE)
#dd=dd[dd.randomise,]
#richness = number of species per microcosm
richness=rowSums(dd)
#n.sp = number of species in the pool of available species
n.sp=ncol(dd)
#n.microcosms = number of microcosms
n.microcosms=nrow(dd)
#volume in the source plate
vol.source=1000
#volume required per isolate
vol.per.isolate=c()
for(i in 1:n.sp){
vol.per.isolate=c(vol.per.isolate,sum((1/richness)*24*10*dd[,i]))
}
#get number of destination plates
n.dest.plates=nrow(dd)/60 #nb /60 because we're just using the central wells
#if number of destination plates is an integer, remove the decimal part and add one
if(all.equal(nrow(dd)/60,as.integer(nrow(dd)/60))==FALSE){
n.dest.plates=(as.integer(nrow(dd)/60)+1)}
#make sure it's an integer
n.dest.plates=as.integer(n.dest.plates)
#nb using only central wells
destination.rows=rep(rep(LETTERS[2:7],10),n.dest.plates)
destination.cols=rep(rep(2:11,each=6),n.dest.plates)
destination.plate=rep(1:n.dest.plates,each=60)
#define destination plates using every well of 4 destination plates
source.rows=rep(rep(LETTERS[1:8],12),4)
source.cols=rep(rep(1:12,each=8),4)
source.plate=rep(1:4,each=96)
#reps.sp = number of times the species is replicated in the source plate
reps.sp=16
#number of wells of each isolate required in the experiment. Allow 30% extra (so *1.3)
#reps.sp=as.integer((vol.per.isolate/vol.source)*1.4)+1
#sp.start = well in source plate where the species starts.
sp.start=seq(from=1,to=(1+n.sp*max(reps.sp)),by=max(reps.sp))
#source.plate.layout = layout of the source plates
temp=matrix(NA,ncol=12,nrow=8);rownames(temp)=LETTERS[1:8];colnames(temp)=1:12
source.plate.layout=list(temp,temp,temp,temp)
source.plate.sequence=rep(1:n.sp,each=max(reps.sp))
for(i in 1:4){
source.plate.layout[[i]][1:8,]=source.plate.sequence[(((i-1)*96)+1):(((i)*96))]
}
source.plate.layout
#counter=1 #old
#source.increment=0 #old
#source.volume tracker holds the volume remaining in each well, with a separate volume tracker for each isolate
source.volume.tracker=matrix(vol.source,nrow=n.sp,ncol=1)
#source.increment is a counter that keeps track of how many source wells we've gone through for each isolate
source.increment=matrix(0,nrow=n.sp,ncol=1)
#worklist holds the worklist that will be fed into Darth
worklist=c()
#loop through the i each microcosm
for(i in 1:nrow(dd)){
#identify which isolates are in the microcosm
sp=which(dd[i,]==1)
#vol.i = volume of ith microcosm
vol.i=(1/richness[i])*24*10
#loop through each species in the microcosm
for(j in 1:length(sp)){
#add volume to sp[j] source.volume.tracker
source.volume.tracker[sp[j]]=source.volume.tracker[sp[j]]-vol.i
#check to see if we have only 10% of the volume remaining; if so, move to next source well and reset the volume tracker
if(source.volume.tracker[sp[j]]<=250){
source.increment[sp[j]]=source.increment[sp[j]]+1
source.volume.tracker[sp[j]]=vol.source-vol.i
}
worklist=rbind(worklist,c(
source.plate[sp.start[sp[j]]+source.increment[sp[j]]],
source.rows[sp.start[sp[j]]+source.increment[sp[j]]],
source.cols[sp.start[sp[j]]+source.increment[sp[j]]],
destination.plate[i],
destination.rows[i],
destination.cols[i],
(1/richness[i])*24*10)
)
}
if(max(source.increment)>min(reps.sp)){print("WARNING: you have insufficient replication of your source isolates!!")}
}
colnames(worklist)=c("source.plate","source.row","source.column","destination.plate","destination.row","destination.column","vol.ul")
worklist=as.data.frame(worklist)
tapply(as.numeric(as.matrix(worklist$vol.ul)),INDEX=list(worklist$source.row,worklist$source.column,worklist$source.plate),FUN=function(x){sum(x,na.rm=T)})
write.csv(worklist,"Results/worklist-invasion_expt_15-06-2018.csv")
#media worklist
outer.rows=c(rep(LETTERS[1],12),rep(LETTERS[2:7],each=2),rep(LETTERS[8],12))
outer.cols=c(1:12,rep(c(1,12),6),1:12)
dest.plates=1:n.dest.plates
media.rows=rep(outer.rows,n.dest.plates)
media.cols=rep(outer.cols,n.dest.plates)
media.plates=rep(dest.plates,each=length(outer.rows))
media.worklist=cbind(media.plates,media.rows,media.cols,rep(240,length(media.cols)))
colnames(media.worklist)=c("destination.plate","destination.row","destination.column","media.vol.ul")
write.csv(media.worklist,file="Results/media-worklist-expt_16-05-2018.csv")
#dd = design matrix dataframe (read in)
#richness = richness of each microcosm
#n.sp = number of isolates in the pool of available species
#vol.source = volume of liquid in the source plates
#vol.per.isolate = calculated volume required per species for the experiment as a whole
#n.dest.plates = calculated number of destination plates required in the experiment as a whole
#n.microcosms =  number of microcosms in the experiment
#destination.rows = vector of length n.microcosms that holds the row of each microcosm.
#destination.cols = vector of length n.microcosms that holds the column of each microcosm.
#destination.plate = vector of length n.microcosms that holds the plate number of each microcosm.
#source.rows =  vector of length 384 that holds the row of each source species
#source.cols =  vector of length 384 that holds the row of each source species
#source.plate =  vector of length 384 that holds the row of each source species
#source.plate.layout = layout of each source plate showing location of each isolate
#source.volume.tracker = vector of length n.sp which holds the volume remaining in the source well currently being used, with starting volume of vol.source
#source.increment = vector of length n.sp. If all of the liquid is used up according to source.volume.tracker for species X, source.increment for X increases by one, which shifts the well being used as the source well for X over by one.
#worklist = holds the main worklist
#outer.rows = defines the outer rows of each destination plate
#outer.cols = defines the outer columns of each destination plate
#media.worklist = holds the main media worklist
rm(list=ls())
setwd("C:/Users/Sam Welch/Google Drive/ICL Ecological Applications/Project/Work/Scripts")
dd=read.table("Data/comb_tibble.txt",header=T)
dd=dd[,1:(ncol(dd)-3)]
#nb randomise here
#dd.randomise=sample(size=nrow(dd),x=1:nrow(dd),replace=FALSE)
#dd=dd[dd.randomise,]
#richness = number of species per microcosm
richness=rowSums(dd)
#n.sp = number of species in the pool of available species
n.sp=ncol(dd)
#n.microcosms = number of microcosms
n.microcosms=nrow(dd)
#volume in the source plate
vol.source=1000
#volume required per isolate
vol.per.isolate=c()
for(i in 1:n.sp){
vol.per.isolate=c(vol.per.isolate,sum((1/richness)*24*10*dd[,i]))
}
#get number of destination plates
n.dest.plates=nrow(dd)/60 #nb /60 because we're just using the central wells
#if number of destination plates is an integer, remove the decimal part and add one
if(all.equal(nrow(dd)/60,as.integer(nrow(dd)/60))==FALSE){
n.dest.plates=(as.integer(nrow(dd)/60)+1)}
#make sure it's an integer
n.dest.plates=as.integer(n.dest.plates)
#nb using only central wells
destination.rows=rep(rep(LETTERS[2:7],10),n.dest.plates)
destination.cols=rep(rep(2:11,each=6),n.dest.plates)
destination.plate=rep(1:n.dest.plates,each=60)
#define destination plates using every well of 4 destination plates
source.rows=rep(rep(LETTERS[1:8],12),4)
source.cols=rep(rep(1:12,each=8),4)
source.plate=rep(1:4,each=96)
#reps.sp = number of times the species is replicated in the source plate
reps.sp=16
#number of wells of each isolate required in the experiment. Allow 30% extra (so *1.3)
#reps.sp=as.integer((vol.per.isolate/vol.source)*1.4)+1
#sp.start = well in source plate where the species starts.
sp.start=seq(from=1,to=(1+n.sp*max(reps.sp)),by=max(reps.sp))
#source.plate.layout = layout of the source plates
temp=matrix(NA,ncol=12,nrow=8);rownames(temp)=LETTERS[1:8];colnames(temp)=1:12
source.plate.layout=list(temp,temp,temp,temp)
source.plate.sequence=rep(1:n.sp,each=max(reps.sp))
for(i in 1:4){
source.plate.layout[[i]][1:8,]=source.plate.sequence[(((i-1)*96)+1):(((i)*96))]
}
source.plate.layout
#counter=1 #old
#source.increment=0 #old
#source.volume tracker holds the volume remaining in each well, with a separate volume tracker for each isolate
source.volume.tracker=matrix(vol.source,nrow=n.sp,ncol=1)
#source.increment is a counter that keeps track of how many source wells we've gone through for each isolate
source.increment=matrix(0,nrow=n.sp,ncol=1)
#worklist holds the worklist that will be fed into Darth
worklist=c()
#loop through the i each microcosm
for(i in 1:nrow(dd)){
#identify which isolates are in the microcosm
sp=which(dd[i,]==1)
#vol.i = volume of ith microcosm
vol.i=(1/richness[i])*24*10
#loop through each species in the microcosm
for(j in 1:length(sp)){
#add volume to sp[j] source.volume.tracker
source.volume.tracker[sp[j]]=source.volume.tracker[sp[j]]-vol.i
#check to see if we have only 10% of the volume remaining; if so, move to next source well and reset the volume tracker
if(source.volume.tracker[sp[j]]<=250){
source.increment[sp[j]]=source.increment[sp[j]]+1
source.volume.tracker[sp[j]]=vol.source-vol.i
}
worklist=rbind(worklist,c(
source.plate[sp.start[sp[j]]+source.increment[sp[j]]],
source.rows[sp.start[sp[j]]+source.increment[sp[j]]],
source.cols[sp.start[sp[j]]+source.increment[sp[j]]],
destination.plate[i],
destination.rows[i],
destination.cols[i],
(1/richness[i])*24*10)
)
}
if(max(source.increment)>min(reps.sp)){print("WARNING: you have insufficient replication of your source isolates!!")}
}
colnames(worklist)=c("source.plate","source.row","source.column","destination.plate","destination.row","destination.column","vol.ul")
worklist=as.data.frame(worklist)
tapply(as.numeric(as.matrix(worklist$vol.ul)),INDEX=list(worklist$source.row,worklist$source.column,worklist$source.plate),FUN=function(x){sum(x,na.rm=T)})
write.csv(worklist,"Results/worklist-invasion_expt_15-06-2018.csv")
#media worklist
outer.rows=c(rep(LETTERS[1],12),rep(LETTERS[2:7],each=2),rep(LETTERS[8],12))
outer.cols=c(1:12,rep(c(1,12),6),1:12)
dest.plates=1:n.dest.plates
media.rows=rep(outer.rows,n.dest.plates)
media.cols=rep(outer.cols,n.dest.plates)
media.plates=rep(dest.plates,each=length(outer.rows))
media.worklist=cbind(media.plates,media.rows,media.cols,rep(240,length(media.cols)))
colnames(media.worklist)=c("destination.plate","destination.row","destination.column","media.vol.ul")
write.csv(media.worklist,file="Results/media-worklist-expt_16-05-2018.csv")
#dd = design matrix dataframe (read in)
#richness = richness of each microcosm
#n.sp = number of isolates in the pool of available species
#vol.source = volume of liquid in the source plates
#vol.per.isolate = calculated volume required per species for the experiment as a whole
#n.dest.plates = calculated number of destination plates required in the experiment as a whole
#n.microcosms =  number of microcosms in the experiment
#destination.rows = vector of length n.microcosms that holds the row of each microcosm.
#destination.cols = vector of length n.microcosms that holds the column of each microcosm.
#destination.plate = vector of length n.microcosms that holds the plate number of each microcosm.
#source.rows =  vector of length 384 that holds the row of each source species
#source.cols =  vector of length 384 that holds the row of each source species
#source.plate =  vector of length 384 that holds the row of each source species
#source.plate.layout = layout of each source plate showing location of each isolate
#source.volume.tracker = vector of length n.sp which holds the volume remaining in the source well currently being used, with starting volume of vol.source
#source.increment = vector of length n.sp. If all of the liquid is used up according to source.volume.tracker for species X, source.increment for X increases by one, which shifts the well being used as the source well for X over by one.
#worklist = holds the main worklist
#outer.rows = defines the outer rows of each destination plate
#outer.cols = defines the outer columns of each destination plate
#media.worklist = holds the main media worklist
rm(list=ls())
setwd("C:/Users/Sam Welch/Google Drive/ICL Ecological Applications/Project/Work/Scripts")
dd=read.table("Data/comb_tibble.txt",header=T)
dd=dd[,1:(ncol(dd)-3)]
#dd = design matrix dataframe (read in)
#richness = richness of each microcosm
#n.sp = number of isolates in the pool of available species
#vol.source = volume of liquid in the source plates
#vol.per.isolate = calculated volume required per species for the experiment as a whole
#n.dest.plates = calculated number of destination plates required in the experiment as a whole
#n.microcosms =  number of microcosms in the experiment
#destination.rows = vector of length n.microcosms that holds the row of each microcosm.
#destination.cols = vector of length n.microcosms that holds the column of each microcosm.
#destination.plate = vector of length n.microcosms that holds the plate number of each microcosm.
#source.rows =  vector of length 384 that holds the row of each source species
#source.cols =  vector of length 384 that holds the row of each source species
#source.plate =  vector of length 384 that holds the row of each source species
#source.plate.layout = layout of each source plate showing location of each isolate
#source.volume.tracker = vector of length n.sp which holds the volume remaining in the source well currently being used, with starting volume of vol.source
#source.increment = vector of length n.sp. If all of the liquid is used up according to source.volume.tracker for species X, source.increment for X increases by one, which shifts the well being used as the source well for X over by one.
#worklist = holds the main worklist
#outer.rows = defines the outer rows of each destination plate
#outer.cols = defines the outer columns of each destination plate
#media.worklist = holds the main media worklist
rm(list=ls())
setwd("C:/Users/Sam Welch/Google Drive/ICL Ecological Applications/Project/Work/Scripts")
dd=read.table("Data/comb_tibble.txt",header=T)
dd=dd[,1:(ncol(dd)-3)]
#dd = design matrix dataframe (read in)
#richness = richness of each microcosm
#n.sp = number of isolates in the pool of available species
#vol.source = volume of liquid in the source plates
#vol.per.isolate = calculated volume required per species for the experiment as a whole
#n.dest.plates = calculated number of destination plates required in the experiment as a whole
#n.microcosms =  number of microcosms in the experiment
#destination.rows = vector of length n.microcosms that holds the row of each microcosm.
#destination.cols = vector of length n.microcosms that holds the column of each microcosm.
#destination.plate = vector of length n.microcosms that holds the plate number of each microcosm.
#source.rows =  vector of length 384 that holds the row of each source species
#source.cols =  vector of length 384 that holds the row of each source species
#source.plate =  vector of length 384 that holds the row of each source species
#source.plate.layout = layout of each source plate showing location of each isolate
#source.volume.tracker = vector of length n.sp which holds the volume remaining in the source well currently being used, with starting volume of vol.source
#source.increment = vector of length n.sp. If all of the liquid is used up according to source.volume.tracker for species X, source.increment for X increases by one, which shifts the well being used as the source well for X over by one.
#worklist = holds the main worklist
#outer.rows = defines the outer rows of each destination plate
#outer.cols = defines the outer columns of each destination plate
#media.worklist = holds the main media worklist
rm(list=ls())
setwd("C:/Users/Sam Welch/Google Drive/ICL Ecological Applications/Project/Work/Scripts")
dd=read.table("Data/comb_tibble.txt",header=T)
dd=dd[,1:(ncol(dd)-3)]
